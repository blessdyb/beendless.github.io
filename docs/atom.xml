<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Beendless ~ 快节奏,慢生活,无止境</title>
  
  <subtitle>Move Fast, Live Happily, With No End</subtitle>
  <link href="http://blog.beendless.com/atom.xml" rel="self"/>
  
  <link href="http://blog.beendless.com/"/>
  <updated>2021-10-04T08:02:15.456Z</updated>
  <id>http://blog.beendless.com/</id>
  
  <author>
    <name>Yabo Du &amp; Yanrong Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JumpGame  Problems</title>
    <link href="http://blog.beendless.com/2021/10/03/JumpGame%20%20Problems/"/>
    <id>http://blog.beendless.com/2021/10/03/JumpGame%20%20Problems/</id>
    <published>2021-10-04T05:05:24.000Z</published>
    <updated>2021-10-04T08:02:15.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/">55. Jump Game</a></h2><p>a. Greedy solutions</p><p>At each step, a greedy jump can give us the local optimal furthest solution. Our global solution can be found in if we always take the greedy jump.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    distance := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= distance; i++ &#123; <span class="comment">// Note: here we use distance to control which items we can check</span></span><br><span class="line">        <span class="keyword">if</span> distance &lt; i + nums[i] &#123;</span><br><span class="line">            distance = i + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> distance &gt;= length - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; length; j++ &#123;</span><br><span class="line">                dp[i + j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a></h2><p>a. Greedy solution</p><p>Each time, we will jump to a position which can make us future jumping even further. And each jump will resolve to a coverage range as below, so the total jump steps will be the sum of times we reach to the edge of the coverge range.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 2 | 3 | 1 | 1 | 4 | 5 | 1 | 2 |</span><br><span class="line"></span><br><span class="line">|----------&gt;|</span><br><span class="line">    |--------------&gt;|</span><br><span class="line"></span><br><span class="line">                |--------------&gt;|</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> max &lt; nums[i] + i &#123;  <span class="comment">// Get the next coverage edge</span></span><br><span class="line">            max = nums[i] + i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == end &#123;           <span class="comment">// Switch to the next range with a jump</span></span><br><span class="line">            end = max</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i + j] == <span class="number">-1</span> &#123;</span><br><span class="line">                dp[i + j] = dp[i] + <span class="number">1</span>   </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> dp[i + j] &gt; dp[i] + <span class="number">1</span> &#123;</span><br><span class="line">                dp[i + j] = dp[i] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/">1306. Jump Game III</a></h2><p>The keypoint here is during the traversal of the recursive, we don’t get lost in a infinite loop. So we need to remember all of the visted nodes in a hash.</p><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    reachedNodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">var</span> jump <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    jump = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reachedNodes[index] &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        reachedNodes[index] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> index - arr[index] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            jump(index - arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index + arr[index] &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">            jump(index + arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jump(start)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Queue traversal solution.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    reachedNodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;start&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        index := queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        reachedNodes[index] = <span class="literal">true</span></span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> index + arr[index] &lt; length &amp;&amp; !reachedNodes[index + arr[index]] &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, index + arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index - arr[index] &lt; length &amp;&amp; !reachedNodes[index - arr[index]] &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, index - arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a><a href="https://leetcode.com/problems/jump-game-iv/">1345. Jump Game IV</a></h2><h2 id="1340-Jump-Game-V"><a href="#1340-Jump-Game-V" class="headerlink" title="1340. Jump Game V"></a><a href="https://leetcode.com/problems/jump-game-v/">1340. Jump Game V</a></h2><h2 id="1696-Jump-Game-VI"><a href="#1696-Jump-Game-VI" class="headerlink" title="1696. Jump Game VI"></a><a href="https://leetcode.com/problems/jump-game-vi/">1696. Jump Game VI</a></h2><h2 id="1871-Jump-Game-VII"><a href="#1871-Jump-Game-VII" class="headerlink" title="1871. Jump Game VII"></a><a href="https://leetcode.com/problems/jump-game-vii/">1871. Jump Game VII</a></h2><p>A naive idea is to iterate over all nodes, so the worse time complexity could be O(n * k) [K = maxJump - minJump] which most likely will cause a TLE issue. A keypoint to solve this problem is we need to avoid the duplicated node visiting. One way is we can use a hashmap to note all visited elements. Another method is that we can bypass the overlap like below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01010101010101011111</span><br><span class="line">  |---------&gt;|</span><br><span class="line">  1          2</span><br><span class="line">    |---------&gt;|</span><br><span class="line">    3          4</span><br></pre></td></tr></table></figure><p>The first jump range is 1 ~ 2, the second is 3 ~ 4, here the range 3 ~ 2 doesn’t need to be visited again. With this in mind, we can use tree-like traversal solution with queue or two pointers sliding window to fix this issue.</p><p>a. Queue with traversal solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(s <span class="keyword">string</span>, minJump <span class="keyword">int</span>, maxJump <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    edge := <span class="number">0</span></span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        index := queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        left := index + minJump</span><br><span class="line">        right := min(length - <span class="number">1</span>, index + maxJump)</span><br><span class="line">        <span class="keyword">for</span> i := max(edge + <span class="number">1</span>, left); i &lt;= right; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; !visited[i]&#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edge = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Two pointers sliding window</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(s <span class="keyword">string</span>, minJump <span class="keyword">int</span>, maxJump <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s[length - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">                <span class="keyword">return</span> b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        canVisit := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">        canVisit[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        edge := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= edge &amp;&amp; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> canVisit[i] &#123;</span><br><span class="line">                left := i + minJump</span><br><span class="line">                right := min(length - <span class="number">1</span>, i + maxJump)</span><br><span class="line">                <span class="keyword">for</span> j := max(left, edge + <span class="number">1</span>); j &lt;= right; j++ &#123;</span><br><span class="line">                    <span class="keyword">if</span> s[j] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                        canVisit[j] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">if</span> j == length - <span class="number">1</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                edge = right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;55-Jump-Game&quot;&gt;&lt;a href=&quot;#55-Jump-Game&quot; class=&quot;headerlink&quot; title=&quot;55. Jump Game&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
    <category term="DFS" scheme="http://blog.beendless.com/tags/DFS/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
    <category term="JumpGame" scheme="http://blog.beendless.com/tags/JumpGame/"/>
    
    <category term="Dynamic Programming" scheme="http://blog.beendless.com/tags/Dynamic-Programming/"/>
    
    <category term="Two Pointers" scheme="http://blog.beendless.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Stock Exchange Problems</title>
    <link href="http://blog.beendless.com/2021/10/03/Stock%20Exchange%20Problems/"/>
    <id>http://blog.beendless.com/2021/10/03/Stock%20Exchange%20Problems/</id>
    <published>2021-10-04T01:25:24.000Z</published>
    <updated>2021-10-04T05:06:01.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><p>a. Greedy solution</p><p>To gian the maximum amount of profit, we just need to accumulate the position profits if we buy it on the previous day and sell it on the next day.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        profit := prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> profit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result += profit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Peak &amp; Valley solution</p><p>A naive approach is find the local lowest price (valley price) and sell it at the next local highest price (peak price). Then we accumulate all of those local profits.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    peak := prices[<span class="number">0</span>]</span><br><span class="line">    valley := prices[<span class="number">0</span>]</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        valley = prices[i]</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        peak = prices[i]</span><br><span class="line">        result += peak - valley</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="keyword">int</span>, length)</span><br><span class="line">    <span class="comment">// dp[i][0] on day i we are holding stock</span></span><br><span class="line">    <span class="comment">// dp[i][1] on day i we don&#x27;t have stock</span></span><br><span class="line">    dp[<span class="number">0</span>] = [<span class="number">2</span>]<span class="keyword">int</span>&#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="comment">// stock we got from day i - 1, or stock we are going to buy on day i</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">        <span class="comment">// we don&#x27;t have stock from day i - 1, or we are going to sell stock we got from day i - 1</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[length - <span class="number">1</span>][<span class="number">0</span>], dp[length - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II&quot; class=&quot;headerlink&quot; title=&quot;122. Best Time t</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
    <category term="Dynamic Programming" scheme="http://blog.beendless.com/tags/Dynamic-Programming/"/>
    
    <category term="Stock Exchange" scheme="http://blog.beendless.com/tags/Stock-Exchange/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Problems - I</title>
    <link href="http://blog.beendless.com/2021/10/03/Greedy%20%20Problems%20I/"/>
    <id>http://blog.beendless.com/2021/10/03/Greedy%20%20Problems%20I/</id>
    <published>2021-10-03T17:25:24.000Z</published>
    <updated>2021-10-04T05:04:44.655Z</updated>
    
    <content type="html"><![CDATA[<p>Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. So <strong>the problems where choosing locally optimal also leads to global solution are best fit for Greedy</strong>.</p><h2 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.com/problems/assign-cookies/">455. Assign Cookies</a></h2><p>If every child is content, then all children are content. So local optimal leads to a global optimal solution. We can use greedy. Now we want to make more child happy, we can use greedy algorithm to give the children whose gratitude is lower first.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="keyword">int</span>, s []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(g) &amp;&amp; j &lt; <span class="built_in">len</span>(s); j++&#123;</span><br><span class="line">        <span class="keyword">if</span> g[i] &lt;= s[i] &#123;</span><br><span class="line">            i++</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a><a href="https://leetcode.com/problems/wiggle-subsequence/">376. Wiggle Subsequence</a></h2><p>a. Greedy solution</p><p>If all connected neighbour nodes are wiggle, the whole slice will be wiggle, it means we can use greedy algorithm. We can also draw the wave with all elements in the slice, our target is to calculate how many peaks (positive/negative) in the wave, here the peak is elements which left diff and right diff have different symbols.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    previous := <span class="number">0</span></span><br><span class="line">    current := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        current = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span> &amp;&amp; previous &lt;= <span class="number">0</span>) || (current &lt; <span class="number">0</span> &amp;&amp; previous &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming solution. Since we want to get the <strong>maximum number</strong>, the first algorithm in our mind will be dynamic programming. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">    dpUp := <span class="number">1</span></span><br><span class="line">    dpDown := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">            dpUp = dpDown + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">            dpDown = dpUp + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dpUp &gt; dpDown &#123;</span><br><span class="line">        <span class="keyword">return</span> dpUp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpDown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></h2><p>A naive solution will be using a two level nested for loop to go through all combinations of subsets.</p><p>a. Greedy implementation</p><p>The idea of using greedy algorithm is when calculating the local maximum sum, if the current sum of all previous elements are negative, we will reset the start point as the current element.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := nums[<span class="number">0</span>]</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; result &#123;</span><br><span class="line">            result = sum</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := nums[<span class="number">0</span>]</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i - <span class="number">1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result &lt; dp[i] &#123;</span><br><span class="line">            result = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := nums[<span class="number">0</span>]</span><br><span class="line">    dp := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp &lt; <span class="number">0</span> &#123;</span><br><span class="line">            dp = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp = dp + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result &lt; dp &#123;</span><br><span class="line">            result = dp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Devide and conquer </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    getCrossMiddleMaxSubArray := <span class="function"><span class="keyword">func</span><span class="params">(start, end, middle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> middle &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i := middle - <span class="number">1</span>; i &gt;= start; i-- &#123;</span><br><span class="line">                sum += nums[i]</span><br><span class="line">                <span class="keyword">if</span> sum &gt; left &#123;</span><br><span class="line">                    left = sum</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> middle &lt; end &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i := middle + <span class="number">1</span>; i &lt;= end; i++ &#123;</span><br><span class="line">                sum += nums[i]</span><br><span class="line">                <span class="keyword">if</span> sum &gt; right &#123;</span><br><span class="line">                    right = sum</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + nums[middle] + right</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> getMaxSubArray <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    getMaxSubArray = <span class="function"><span class="keyword">func</span><span class="params">(start, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == end &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (start + end) / <span class="number">2</span></span><br><span class="line">        left := getMaxSubArray(start, mid)</span><br><span class="line">        right := getMaxSubArray(mid + <span class="number">1</span>, end)</span><br><span class="line">        middle := getCrossMiddleMaxSubArray(start, end, mid)</span><br><span class="line">        <span class="keyword">return</span> max(max(left, middle), right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMaxSubArray(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><p>a. Greedy solution</p><p>To gian the maximum amount of profit, we just need to accumulate the position profits if we buy it on the previous day and sell it on the next day.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        profit := prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> profit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result += profit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Peak &amp; Valley solution</p><p>A naive approach is find the local lowest price (valley price) and sell it at the next local highest price (peak price). Then we accumulate all of those local profits.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    peak := prices[<span class="number">0</span>]</span><br><span class="line">    valley := prices[<span class="number">0</span>]</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        valley = prices[i]</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        peak = prices[i]</span><br><span class="line">        result += peak - valley</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="keyword">int</span>, length)</span><br><span class="line">    <span class="comment">// dp[i][0] on day i we are holding stock</span></span><br><span class="line">    <span class="comment">// dp[i][1] on day i we don&#x27;t have stock</span></span><br><span class="line">    dp[<span class="number">0</span>] = [<span class="number">2</span>]<span class="keyword">int</span>&#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="comment">// stock we got from day i - 1, or stock we are going to buy on day i</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">        <span class="comment">// we don&#x27;t have stock from day i - 1, or we are going to sell stock we got from day i - 1</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[length - <span class="number">1</span>][<span class="number">0</span>], dp[length - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious a</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Chessboard</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Chessboard/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Chessboard/</id>
    <published>2021-10-02T05:25:24.000Z</published>
    <updated>2021-10-03T06:11:25.855Z</updated>
    
    <content type="html"><![CDATA[<p>Backtracking can also be used to solve chessboard problems.</p><h2 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a><a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="keyword">string</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid := <span class="function"><span class="keyword">func</span><span class="params">(row, col <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; col; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[row][i] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i, j = i - <span class="number">1</span>, j + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(row <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == n &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</span><br><span class="line">            <span class="keyword">for</span> i, boardRow := <span class="keyword">range</span> board &#123;</span><br><span class="line">                temp[i] = strings.Join(boardRow, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isValid(row, col) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                backtracking(row + <span class="number">1</span>)</span><br><span class="line">                board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a><a href="https://leetcode.com/problems/n-queens-ii/">52. N-Queens II</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="keyword">string</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid := <span class="function"><span class="keyword">func</span><span class="params">(row, col <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; col; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[row][i] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i, j = i - <span class="number">1</span>, j + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(row <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == n &#123;</span><br><span class="line">            result++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isValid(row, col) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                backtracking(row + <span class="number">1</span>)</span><br><span class="line">                board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    isValid := <span class="function"><span class="keyword">func</span><span class="params">(row, col <span class="keyword">int</span>, value <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == value || board[row][i] == value&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        squareX := (row / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        squareY := (col / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> board[i + squareX][j + squareY] == value &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> k := <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++ &#123;</span><br><span class="line">                        <span class="keyword">if</span> isValid(i, j, <span class="keyword">byte</span>(k)) &#123;</span><br><span class="line">                            board[i][j] = <span class="keyword">byte</span>(k)</span><br><span class="line">                            <span class="keyword">if</span> backtracking() &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    backtracking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Backtracking can also be used to solve chessboard problems.&lt;/p&gt;
&lt;h2 id=&quot;51-N-Queens&quot;&gt;&lt;a href=&quot;#51-N-Queens&quot; class=&quot;headerlink&quot; title=&quot;51.</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://blog.beendless.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Subsets</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Subsets/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Subsets/</id>
    <published>2021-10-02T03:05:24.000Z</published>
    <updated>2021-10-03T05:22:26.977Z</updated>
    
    <content type="html"><![CDATA[<p>Backtracking can also help us to get all subsets of a given slice. If Combination and Partitioning problems can be converted to get root-to-leaf paths during a tree DFS traversal, Subsets can be treated as getting all root-to-node paths during a tree DFS traversal.</p><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            backtracking(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h2><p>It’s similar to #78, the only difference is we can’t have duplicated subsets, which means we can’t pick the same value at the same tree level during traversal.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path := <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            backtracking(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="491-Increasing-Subsequences"><a href="#491-Increasing-Subsequences" class="headerlink" title="491. Increasing Subsequences"></a><a href="https://leetcode.com/problems/increasing-subsequences/">491. Increasing Subsequences</a></h2><p>Since we can’t sort the given slice, so we have to use a hashmap / array to save the used nodes in the same layer.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apth) == length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        used := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span>(path) &gt; <span class="number">0</span> &amp;&amp; path[<span class="built_in">len</span>(path) - <span class="number">1</span>] &gt; nums[i]) || used[nums[i]] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[nums[i]] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">                <span class="built_in">copy</span>(temp, path)</span><br><span class="line">                result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Backtracking can also help us to get all subsets of a given slice. If Combination and Partitioning problems can be converted to get root-</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Subsets" scheme="http://blog.beendless.com/tags/Subsets/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Partioning</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Partitioning/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Partitioning/</id>
    <published>2021-10-02T01:05:24.000Z</published>
    <updated>2021-10-02T01:07:37.589Z</updated>
    
    <content type="html"><![CDATA[<p>Partitioning is another classical problem which can be solved with backtracking algorithm.</p><h2 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    isParlindrom := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>; i &lt; j; i, j := i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == length &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isParlindrom(s[index:i + <span class="number">1</span>]) &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, s[index: i + <span class="number">1</span>])</span><br><span class="line">                backtracking(i + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a><a href="https://leetcode.com/problems/restore-ip-addresses/">93. Restore IP Addresses</a></h2><p>We need to consider the edge case that some numbers start with 0 since golang’s <code>strconv.Atoi</code> will convert those string to integer successfully.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &gt; length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index == length &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, strings.Join(path, <span class="string">&quot;.&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i - index &lt;= <span class="number">2</span> &#123;</span><br><span class="line">                num, _ := strconv.Atoi(s[index:i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> (i - index == <span class="number">2</span> &amp;&amp; num &lt; <span class="number">100</span>) || (i - index == <span class="number">1</span> &amp;&amp; num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> num &lt; <span class="number">256</span> &#123;</span><br><span class="line">                    path = <span class="built_in">append</span>(path, s[index:i + <span class="number">1</span>])</span><br><span class="line">                    backtracking(i + <span class="number">1</span>)</span><br><span class="line">                    path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Partitioning is another classical problem which can be solved with backtracking algorithm.&lt;/p&gt;
&lt;h2 id=&quot;131-Palindrome-Partitioning&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://blog.beendless.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Combinations</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Combinations/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Combinations/</id>
    <published>2021-10-01T20:35:24.000Z</published>
    <updated>2021-10-01T22:19:19.821Z</updated>
    
    <content type="html"><![CDATA[<p>Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time (by time, here, is referred to the time elapsed till reaching any level of the search tree). Usually we can consider backtracking as DFS recursively traversal.</p><h2 id="Backtracking-template"><a href="#Backtracking-template" class="headerlink" title="Backtracking template"></a>Backtracking template</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtracking</span><span class="params">(...args)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> stop_condition &#123;</span><br><span class="line">        <span class="comment">// Update the result set</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nodes_in_current_layer(...args) &#123;</span><br><span class="line">        <span class="comment">// Down to next layer</span></span><br><span class="line">        backtracking(...args, i + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Go back to the upper layer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-Binary-search-tree/">77. Combinations</a></h2><p>We can’t use a naive bruth force algorithm to solve this one, since it’s almost impossible to write a N-layers nested for loop.</p><p>a. Naive backtracking solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n, k, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt;= n; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Remove the unnecessary backtracking branches</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n, k <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n, k, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// For example, given n = 4, k = 3, if path is empty, n - (k - 0) + 1 = 2 means the last valid index can be 2</span></span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt;= n - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.com/problems/combination-sum-iii/">216. Combination Sum III</a></h2><p>Similar to #77, we can use the backtracking template to solve it.</p><p>a. Naive backtracking solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    results := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(k, n, index, sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            <span class="keyword">if</span> sum == n &#123;</span><br><span class="line">                temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">                <span class="built_in">copy</span>(temp, path)</span><br><span class="line">                results = <span class="built_in">append</span>(results, temp)  </span><br><span class="line">            &#125;             </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>, sum + i)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Remove the unnecessary backtracking branches</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(k, n, index, sum)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            <span class="keyword">if</span> sum == n &#123;</span><br><span class="line">                temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">                <span class="built_in">copy</span>(temp, path)</span><br><span class="line">                result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; <span class="number">9</span> - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>, sum + i)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></h2><p>The only difference between #216 and this one is we can reuse the elements of the slice. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(candidates)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(target, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            backtracking(target - candidates[i], i)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h2><p>Since we don’t know how long the given digits will be, we have to use backtracking.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        digitsMap := [<span class="number">10</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">            <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">            <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">            <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">            <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">            <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">        &#125;</span><br><span class="line">        path := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">        backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, <span class="keyword">string</span>(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            digit, _ := strconv.Atoi(<span class="keyword">string</span>(digits[index]))</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(digitsMap[digit]); i++ &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, digitsMap[digit][i])</span><br><span class="line">                backtracking(index + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II</a></h2><p>Since we can convert a combination backtracking problem to a DFS traversal problem,  if we don’t want to have the duplicated combination result item, it means we can’t pick duplicated nodes from the same layer of a tree. According to the backtracking template, in side of the backtracking for-loop we are handling the same layer logic (push/pop). At this point, if the given candidates is a sorted slice, we just need to compare if the previous element equals to the current element in the same layer.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(candidates)</span><br><span class="line">    sort.Ints(candidates)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(target, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            backtracking(target - candidates[i], i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a tim</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://blog.beendless.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Modify Trees</title>
    <link href="http://blog.beendless.com/2021/09/27/Modify%20Trees/"/>
    <id>http://blog.beendless.com/2021/09/27/Modify%20Trees/</id>
    <published>2021-09-28T06:35:24.000Z</published>
    <updated>2021-09-29T05:03:34.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-Binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a></h2><p>Highed balanced means left nodes and right nodes have the minimized same size difference.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    node := &amp;TreeNode&#123;nums[mid], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    node.Left = sortedArrayToBST(nums[:mid])</span><br><span class="line">    node.Right = sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></h2><p>Naive BST recursively traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></h2><p>Naive BST recursively traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">            <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root.Left</span><br><span class="line">            &#125;</span><br><span class="line">            node := root.Right</span><br><span class="line">            <span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                node = node.Left</span><br><span class="line">            &#125;</span><br><span class="line">            node.Left = root.Left</span><br><span class="line">            <span class="keyword">return</span> root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">            root.Right = deleteNode(root.Right, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.Left = deleteNode(root.Left, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a><a href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a></h2><p>Since it’s a BST, we can avoid some calculation by comparing the root value with low, high value.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.Right, low, high)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.Left, low, high)</span><br><span class="line">        &#125;</span><br><span class="line">        root.Left = trimBST(root.Left, low, high)</span><br><span class="line">        root.Right = trimBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h2><p>Since Inorder BST is a sorted slice, for greater tree, we need to get a reversed slice, which means we can still follow the Inorder traversal of the tree but right child node first.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, current)</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            current = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            sum += current.Val</span><br><span class="line">            current.Val = sum</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;108-Convert-Sorted-Array-to-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#108-Convert-Sorted-Array-to-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Search in Trees</title>
    <link href="http://blog.beendless.com/2021/09/27/Search%20in%20Trees/"/>
    <id>http://blog.beendless.com/2021/09/27/Search%20in%20Trees/</id>
    <published>2021-09-28T04:35:24.000Z</published>
    <updated>2021-09-28T06:07:26.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></h2><p>Naive BST query.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret *TreeNode</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Val == val &#123;</span><br><span class="line">            ret = current</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> current.Val &gt; val &#123;</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h2><p>Since Inorder Traversal a BST we will get a sorted list, we just need to compare the previous value with current value during the traversal.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    previous := math.Inf(<span class="number">-1</span>)</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">float64</span>(node.Val) &lt;= previous &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            previous = <span class="keyword">float64</span>(node.Val)</span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST</a></h2><p>a. In Order transverse of BST with stack, we can set up two pointers to check the difference</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">100001</span></span><br><span class="line">    <span class="keyword">var</span> previous, current <span class="keyword">int</span></span><br><span class="line">    node := root</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> count &gt; <span class="number">0</span> &#123;</span><br><span class="line">                previous = current</span><br><span class="line">            &#125;</span><br><span class="line">            current = node.Val</span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">1</span> &amp;&amp; ret &gt; current - previous &#123;</span><br><span class="line">                ret = current - previous</span><br><span class="line">            &#125;</span><br><span class="line">            count++</span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Recurrsively Inorder Traversal with two pointers</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(node.Left)</span><br><span class="line">            data = <span class="built_in">append</span>(data, node.Val)</span><br><span class="line">            dfs(node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    min := data[<span class="number">1</span>] - data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">2</span>; j &lt; <span class="built_in">len</span>(data); i, j = i + <span class="number">1</span>, j + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> min &gt; data[j] - data[i] &#123;</span><br><span class="line">            min = data[j] - data[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree</a></h2><p>Since it’s a BST, we can get a sorted slice with inorder traversal of the tree. Once we have the sorted slice, we can use two pointers sliding window to get a mode result. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    maxCount := <span class="number">1</span></span><br><span class="line">    previous := <span class="number">100001</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(root.Left)</span><br><span class="line">            <span class="keyword">if</span> previous == root.Val &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count &gt; maxCount &#123;</span><br><span class="line">                maxCount = count</span><br><span class="line">                result = []<span class="keyword">int</span>&#123;root.Val&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> count == maxCount &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            previous = root.Val</span><br><span class="line">            dfs(root.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A naive solution which can apply to all trees (not only binary tree) is we create a frequence map with a tree traversal. Then sort the map values and get the higher frequency list.</p><h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h2><p>a. Pass down parent informatin layer by layer to get two slices, then find the first common items.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [[root, []]];</span><br><span class="line">    <span class="keyword">let</span> pPath, qPath;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &amp;&amp; (!pPath || !qPath)) &#123;</span><br><span class="line">        <span class="keyword">const</span> [node, ancestor] = stack.shift();</span><br><span class="line">        <span class="keyword">const</span> newAncestor = ancestor.concat([node]);</span><br><span class="line">        <span class="keyword">if</span> (node.val === p.val) &#123;</span><br><span class="line">            pPath = newAncestor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val === q.val) &#123;</span><br><span class="line">            qPath = newAncestor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">            stack.push([node.left, newAncestor]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">            stack.push([node.right, newAncestor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = root;</span><br><span class="line">    <span class="keyword">while</span>(pPath.length &amp;&amp; qPath.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = pPath.shift();</span><br><span class="line">        <span class="keyword">const</span> y = qPath.shift();</span><br><span class="line">        <span class="keyword">if</span> (x.val === y.val) &#123;</span><br><span class="line">            result = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>b. If we search a tree from bottom layer to top, we can easily get the ancestor node. Postorder traversal can help us to go from bottom to up.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || root == p || root == q &#123;   <span class="comment">// edge case</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)    </span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;    <span class="comment">// Postorder Traversal</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h2><p>Since it’s a BST, we can compare the value to remove some unnecessary calculation.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;700-Search-in-a-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#700-Search-in-a-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;700. Search in a Binary </summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Construct and Update a Tree</title>
    <link href="http://blog.beendless.com/2021/09/23/Construct-and-Update-a-Tree/"/>
    <id>http://blog.beendless.com/2021/09/23/Construct-and-Update-a-Tree/</id>
    <published>2021-09-23T07:00:24.000Z</published>
    <updated>2021-09-23T07:15:33.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. Construct Binary Search Tree from Preorder Traversal</a></h2><p>Based on the preorder traversal definition for a BST, the first element in the slice is always coming from the root node, we can split the rest elements into two parts from the element which is no less than the root node for child nodes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bstFromPreorder</span><span class="params">(preorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    length := <span class="built_in">len</span>(preorder)</span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">0</span> &#123;</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = preorder[<span class="number">0</span>]</span><br><span class="line">        i := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">            <span class="keyword">if</span> preorder[i] &gt;= root.Val &#123;</span><br><span class="line">               <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        root.Left = bstFromPreorder(preorder[<span class="number">1</span>:i])</span><br><span class="line">        root.Right = bstFromPreorder(preorder[i:])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p>The last element in postorder slice is the root node, with this information, we can split inorder to a left subtree and a right subtree. Since now we know the amount of nodes in the left subtree, we can go back to split the postorder list into two.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        rootValue := postorder[<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.Val = rootValue</span><br><span class="line">        inorderLeftIndex := indexOf(inorder, rootValue)</span><br><span class="line">        inorderLeft := inorder[:inorderLeftIndex]</span><br><span class="line">        inorderRight := inorder[inorderLeftIndex + <span class="number">1</span>:]</span><br><span class="line">        postorderLeft := postorder[:<span class="built_in">len</span>(inorderLeft)]</span><br><span class="line">        postorderRight := postorder[<span class="built_in">len</span>(inorderLeft):<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.Left = buildTree(inorderLeft, postorderLeft)</span><br><span class="line">        root.Right = buildTree(inorderRight, postorderRight)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2><p>Similar to the above one, we can get the root node first from preorder slice.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">        rootValueIndex := indexOf(inorder, rootValue)</span><br><span class="line">        inorderLeft := inorder[:rootValueIndex]</span><br><span class="line">        inorderRight := inorder[rootValueIndex + <span class="number">1</span>:]</span><br><span class="line">        preorderLeft := preorder[<span class="number">1</span>:<span class="built_in">len</span>(inorderLeft) + <span class="number">1</span>]</span><br><span class="line">        preorderRight := preorder[<span class="built_in">len</span>(inorderLeft) + <span class="number">1</span>:]</span><br><span class="line">        root = &amp;TreeNode&#123;</span><br><span class="line">            Val: rootValue,</span><br><span class="line">            Left: buildTree(preorderLeft, inorderLeft),</span><br><span class="line">            Right: buildTree(preorderRight, inorderRight),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal</a></h2><p>With the second element in preorder slice, we can split postorder slice into two sub slices. With this information we can go back to split the preorder slice into two sub slices with the same sizes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructFromPrePost</span><span class="params">(preorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = rootValue</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">1</span> &#123;</span><br><span class="line">            leftValue := preorder[<span class="number">1</span>]</span><br><span class="line">            leftValueIndex := indexOf(postorder, leftValue)</span><br><span class="line">            postorderLeft := postorder[:leftValueIndex + <span class="number">1</span>]</span><br><span class="line">            postorderRight := postorder[leftValueIndex + <span class="number">1</span>:<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">            preorderLeft := preorder[<span class="number">1</span>:<span class="built_in">len</span>(postorderLeft) + <span class="number">1</span>]</span><br><span class="line">            preorderRight := preorder[<span class="built_in">len</span>(postorderRight) + <span class="number">1</span>:]    </span><br><span class="line">            root.Left = constructFromPrePost(preorderLeft, postorderLeft)</span><br><span class="line">            root.Right = constructFromPrePost(preorderRight, postorderRight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></h2><p>Find the maximu value, then split the slice with the max value to get two sub slices.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxIndex</span><span class="params">(haystack []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := <span class="number">-1</span></span><br><span class="line">    ret := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] &gt; max &#123;</span><br><span class="line">            max = haystack[i]</span><br><span class="line">            ret = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        max := maxIndex(nums)</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = nums[max]</span><br><span class="line">        root.Left = constructMaximumBinaryTree(nums[:max])</span><br><span class="line">        root.Right = constructMaximumBinaryTree(nums[max+<span class="number">1</span>:])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a><a href="https://leetcode.com/problems/maximum-binary-tree-ii/">998. Maximum Binary Tree II</a></h2><p>With the idea from the above one, since <code>Suppose b is a copy of a with the value val appended to it. </code>, it means <code>b</code> can only be the root node or part of right subtree based on the tree construction rule.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoMaxTree</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &amp;&amp; root.Val &gt; val &#123;</span><br><span class="line">        root.Right = insertIntoMaxTree(root.Right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">        Val: val,</span><br><span class="line">        Left: root,</span><br><span class="line">        Right: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> root1 != <span class="literal">nil</span> || root2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = root2</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = root1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = &amp;TreeNode&#123;</span><br><span class="line">                Val: root1.Val + root2.Val,</span><br><span class="line">                Left: mergeTrees(root1.Left, root2.Left),</span><br><span class="line">                Right: mergeTrees(root1.Right, root2.Right),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1008-Construct-Binary-Search-Tree-from-Preorder-Traversal&quot;&gt;&lt;a href=&quot;#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal&quot; clas</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Tree Properties</title>
    <link href="http://blog.beendless.com/2021/09/19/Tree-Properties/"/>
    <id>http://blog.beendless.com/2021/09/19/Tree-Properties/</id>
    <published>2021-09-20T04:35:24.000Z</published>
    <updated>2021-09-22T06:54:02.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h2><p>a. DFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testSymmetric(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSymmetric</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; b != <span class="literal">nil</span> &amp;&amp; a.Val == b.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> testSymmetric(a.Left, b.Right) &amp;&amp; testSymmetric(a.Right, b.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i, j := <span class="number">0</span>, n - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !testSymmetric(queue[i], queue[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[i]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSymmetric</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; b != <span class="literal">nil</span> &amp;&amp; a.Val == b.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h2><p>Same to the symmetric tree question.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &amp;&amp; p.Val == q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572. Subtree of Another Tree"></a><a href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree</a></h2><p>a. Naive DFS solution</p><p>We will check if the given two trees are the same or not, if not, then check if the subRoot is the sub tree of the root tree’s child nodes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isSameTree(root, subRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root != <span class="literal">nil</span> &amp;&amp; (isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &amp;&amp; p.Val == q.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Serialize tree to string and compare the string</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> toString(root) == toString(subRoot) || (root != <span class="literal">nil</span> &amp;&amp; (isSubtree(root.Left, subRoot) ||  isSubtree(root.Right, subRoot)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strconv.Itoa(root.Val) + toString(root.Left) + toString(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h2><p>a. DFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        max := math.Inf(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> _, node := <span class="keyword">range</span> root.Children &#123;</span><br><span class="line">            depth := maxDepth(node)</span><br><span class="line">            <span class="keyword">if</span> max &lt; <span class="keyword">float64</span>(depth) &#123;</span><br><span class="line">                max = <span class="keyword">float64</span>(depth)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max == math.Inf(<span class="number">-1</span>) &#123;</span><br><span class="line">            max = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="keyword">int</span>(max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*Node&#123;root&#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            length := <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">                node := queue[i]</span><br><span class="line">                <span class="keyword">for</span> _, child := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, child)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[length:]</span><br><span class="line">            n++</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.com/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h2><p>a. DFS recursion</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.Left) + countNodes(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS recursion</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            n++</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Complete tree property</p><p>For a full binary tree, it has 2<sup>depth</sup> - 1 nodes. Since a full binary tree is a subset of complete tree, based on the equation, we can calculate the nodes of a given tree if it’s left most child node’s depth equals it’s right most child note’s depth.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := root.Left</span><br><span class="line">    right := root.Right</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">        l++</span><br><span class="line">        left = left.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> right != <span class="literal">nil</span> &#123;</span><br><span class="line">        r++</span><br><span class="line">        right = right.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l == r &#123; <span class="comment">// It&#x27;s a full binary tree</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; l - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root.Left) + countNodes(root.Right) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h2><p>The key to solve this challenge is to get the depth of given node’s left and right child.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(root.Left)</span><br><span class="line">        right := getDepth(root.Right)</span><br><span class="line">        <span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(left - right)) &gt; <span class="keyword">float64</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(root.Left)</span><br><span class="line">        right := getDepth(root.Right)</span><br><span class="line">        <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths</a></h2><p>When we traversing the tree, we need to push the parent nodes inforamtion to a queue.</p><p>a. DFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="keyword">string</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, paths <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            p := paths + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(node.Val)</span><br><span class="line">            <span class="keyword">if</span> paths == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                p = strconv.Itoa(node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, p)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    dfs(node.Left, p)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    dfs(node.Right, p)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="keyword">type</span> TreeNodeWithPath <span class="keyword">struct</span> &#123;</span><br><span class="line">    Node *TreeNode</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNodeWithPath&#123;&amp;TreeNodeWithPath&#123;</span><br><span class="line">        Node: root,</span><br><span class="line">        Path: strconv.Itoa(root.Val),</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            twp := queue[i]</span><br><span class="line">            <span class="keyword">if</span> twp.Node.Left == <span class="literal">nil</span> &amp;&amp; twp.Node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, twp.Path)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> twp.Node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, &amp;TreeNodeWithPath&#123;</span><br><span class="line">                        Node: twp.Node.Left,</span><br><span class="line">                        Path: twp.Path + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(twp.Node.Left.Val),</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> twp.Node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, &amp;TreeNodeWithPath&#123;</span><br><span class="line">                        Node: twp.Node.Right,</span><br><span class="line">                        Path: twp.Path + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(twp.Node.Right.Val),</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h2><p>a. DFS recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := <span class="number">0</span></span><br><span class="line">        right := sumOfLeftLeaves(root.Right)</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &amp;&amp; root.Left.Left == <span class="literal">nil</span> &amp;&amp; root.Left.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            left = root.Left.Val</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = sumOfLeftLeaves(root.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS with stack (PreOrder)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, current)</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            current = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> current.Left != <span class="literal">nil</span> &amp;&amp; current.Left.Left == <span class="literal">nil</span> &amp;&amp; current.Left.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result += current.Left.Val</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h2><p>a. Naive solution is to use BFS and get the first node of last layer.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[i]</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue) == n &#123;</span><br><span class="line">            result = queue[<span class="number">0</span>].Val</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. The bottom-left leaf node means two things: 1) this node laid at the bottom layer 2) this node will be reached first if we go with DFS In-Order traversal.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unc findBottomLeftValue(root *TreeNode) <span class="keyword">int</span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    ret := root.Val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="keyword">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &amp;&amp; level &gt; max &#123;</span><br><span class="line">            max = level</span><br><span class="line">            ret = node.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(node.Left, level + <span class="number">1</span>)    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(node.Right, level + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a></h2><p>Naive DFS solution with target passing down to the next layer</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a></h2><p>Similar to the above one, we just need to store extra information</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;    </span><br><span class="line">    <span class="keyword">type</span> TreeNodeWithPath <span class="keyword">struct</span> &#123;</span><br><span class="line">        node *TreeNode</span><br><span class="line">        path []<span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    cloneAppend := <span class="function"><span class="keyword">func</span><span class="params">(source []<span class="keyword">int</span>, item <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(source))</span><br><span class="line">        <span class="built_in">copy</span>(ret, source)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(ret, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNodeWithPath, <span class="keyword">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNodeWithPath, targetSum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> root.node.Left == <span class="literal">nil</span> &amp;&amp; root.node.Right == <span class="literal">nil</span> &amp;&amp; root.node.Val == targetSum &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, cloneAppend(root.path, root.node.Val))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(&amp;TreeNodeWithPath&#123;</span><br><span class="line">                    node: root.node.Left,</span><br><span class="line">                    path: cloneAppend(root.path, root.node.Val),</span><br><span class="line">                &#125;, targetSum - root.node.Val)</span><br><span class="line">                dfs(&amp;TreeNodeWithPath&#123;</span><br><span class="line">                    node: root.node.Right,</span><br><span class="line">                    path: cloneAppend(root.path, root.node.Val),</span><br><span class="line">                &#125;, targetSum - root.node.Val)   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(&amp;TreeNodeWithPath&#123;</span><br><span class="line">        node: root,</span><br><span class="line">        path: []<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">    &#125;, targetSum)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>If we need to clone a slice in golang, usually we will use the snipped as below:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>, b == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>But it’s not perfect, if a is nil, b wont’ be nil. So we need to use <code>b = append(a[:0:0], a...)</code></p><ul><li><a href="https://github.com/go101/go101/wiki/How-to-perfectly-clone-a-slice%3F">https://github.com/go101/go101/wiki/How-to-perfectly-clone-a-slice%3F</a></li></ul><h2 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/">437. Path Sum III</a></h2><p>Based on the problem description, we need to find out all paths from all subtrees of the given tree which sum equals to the targetSum. There’s a pitfall as the edge case, once we got one path (which means the targetSum reaches to 0), we still need to continue the searching since the rest path below may get a total sum 0.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> targetPath(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">targetPath</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        restPath := targetPath(root.Left, targetSum - root.Val) + targetPath(root.right, targetSum - root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Val == targetSum &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + restPath</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> restPath</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;101-Symmetric-Tree&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/p</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Tree Traversals BFS</title>
    <link href="http://blog.beendless.com/2021/09/14/Tree-Traversals-BFS/"/>
    <id>http://blog.beendless.com/2021/09/14/Tree-Traversals-BFS/</id>
    <published>2021-09-15T05:35:24.000Z</published>
    <updated>2021-09-19T19:00:06.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h2><p>a. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution</p><p>The idea is passing the level while traversing the tree</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>, result *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(*result) &lt; level &#123;</span><br><span class="line">            *result = <span class="built_in">append</span>(*result, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        (*result)[level - <span class="number">1</span>] = <span class="built_in">append</span>((*result)[level - <span class="number">1</span>], node.Val)</span><br><span class="line">        dfs(node.Left, level + <span class="number">1</span>, result)</span><br><span class="line">        dfs(node.Right, level + <span class="number">1</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(root, <span class="number">1</span>, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h2><p>We just need to reverse the result of BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h2><p>We just need to get the right most item (last item) of each layer by using BFS.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i == n - <span class="number">1</span> &#123;</span><br><span class="line">                    result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">                &#125;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></h2><p>Get the sum of each level by using BFS or DFS with level information, then claculate the average.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">averageOfLevels</span><span class="params">(root *TreeNode)</span> []<span class="title">float64</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="keyword">float64</span> = <span class="number">0</span></span><br><span class="line">        item := <span class="number">0</span>    <span class="comment">// Track the not nil item</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                sum += <span class="keyword">float64</span>(node.Val)</span><br><span class="line">                item++</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> item &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, sum / <span class="keyword">float64</span>(item))   </span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *Node)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*Node&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                <span class="keyword">for</span> _, child := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, child)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestValues</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*TreeNode&#123;root&#125;</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            max := queue[<span class="number">0</span>].Val</span><br><span class="line">            <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                node := queue[<span class="number">0</span>]</span><br><span class="line">                queue = queue[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> node.Val &gt; max &#123;</span><br><span class="line">                    max = node.Val</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">                &#125;</span><br><span class="line">                n--</span><br><span class="line">            &#125;</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            result = <span class="built_in">append</span>(result, max)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h2><p>a. A naive solution will be using BFS to traverse the tree.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*Node&#123;root&#125;</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    queue[i - <span class="number">1</span>].Next = queue[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> queue[i].Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Left)</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[n:]</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution. Since the given tree is a full complete tree, we can easily use the parent node to get it’s siblings children nodes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    parent := root</span><br><span class="line">    <span class="keyword">for</span> parent.Left != <span class="literal">nil</span> &#123; <span class="comment">// Has child node</span></span><br><span class="line">        current := parent</span><br><span class="line">        <span class="keyword">for</span> current != <span class="literal">nil</span> &#123; <span class="comment">// Moving from left to right</span></span><br><span class="line">            current.Left.Next = current.Right</span><br><span class="line">            <span class="keyword">if</span> current.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">                current.Right.Next = current.Next.Left</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent.Left <span class="comment">// Move to the next layer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.wang/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node.html">https://leetcode.wang/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node.html</a></li></ul><h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117. Populating Next Right Pointers in Each Node II</a></h2><p>The only difference between this one and the above one is we need to verify the node’s right child before push the into the queue.</p><p>a. A naive solution will be using BFS to traverse the tree.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*Node&#123;root&#125;</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    queue[i - <span class="number">1</span>].Next = queue[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> queue[i].Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> queue[i].Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[n:]</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        dummy := &amp;Node&#123;&#125;    <span class="comment">// Dummy pointer which points to the first node in current node&#x27;s child layer</span></span><br><span class="line">        tail := dummy       <span class="comment">// Using tail node to construct a linked list which head is dummy node</span></span><br><span class="line">        <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> current.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                tail.Next = current.Left</span><br><span class="line">                tail := tail.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> current.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                tail.Next = current.Right</span><br><span class="line">                tail = tail.Next</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">        current = dummy.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html">https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html</a></li></ul><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><p>a. BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*TreeNode&#123;root&#125;</span><br><span class="line">        n := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> node := queue[i]; node != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                        queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                        queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[n:]</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            ret++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getDepth(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDepth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(node.Left)</span><br><span class="line">        right := getDepth(node.Right)</span><br><span class="line">        <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;102-Binary-Tree-Level-Order-Traversal&quot;&gt;&lt;a href=&quot;#102-Binary-Tree-Level-Order-Traversal&quot; class=&quot;headerlink&quot; title=&quot;102. Binary Tree L</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
    <category term="BFS" scheme="http://blog.beendless.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Tree Traversals DFS</title>
    <link href="http://blog.beendless.com/2021/09/13/Tree-Traversals-DFS/"/>
    <id>http://blog.beendless.com/2021/09/13/Tree-Traversals-DFS/</id>
    <published>2021-09-14T05:45:24.000Z</published>
    <updated>2021-10-03T04:54:43.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, inorderTraversal(root.Left)...)</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, inorderTraversal(root.Right)...)   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Iterative solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    stack := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;  <span class="comment">// reach to the left most node and push node to stack so we can pop left child node before parent node</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Val)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]  <span class="comment">// pop parent node out if it doesn&#x27;t have left child node</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val) <span class="comment">// switch to right child node</span></span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Morris Traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous := current.Left</span><br><span class="line">            <span class="keyword">for</span> previous.Right != <span class="literal">nil</span> &amp;&amp; previous.Right != current &#123;</span><br><span class="line">                previous = previous.Right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                previous.Right = current</span><br><span class="line">                current = current.Left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == current &#123;</span><br><span class="line">                previous.Right = <span class="literal">nil</span></span><br><span class="line">                result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">                current = current.Right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">        result = <span class="built_in">append</span>(result, preorderTraversal(root.Left)...)</span><br><span class="line">        result = <span class="built_in">append</span>(result, preorderTraversal(root.Right)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Iterative traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Morris Traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous := current.Left</span><br><span class="line">            <span class="keyword">for</span> previous.Right != <span class="literal">nil</span> &amp;&amp; previous.Right != current &#123;</span><br><span class="line">                previous = previous.Right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">                previous.Right = current</span><br><span class="line">                current = current.Left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == current &#123;</span><br><span class="line">                previous.Right = <span class="literal">nil</span></span><br><span class="line">                current = current.Right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">145. Binary Tree Postorder Traversal</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, postorderTraversal(root.Left)...)</span><br><span class="line">        result = <span class="built_in">append</span>(result, postorderTraversal(root.Right)...)</span><br><span class="line">        result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Iterative solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    stack := []*TreeNode&#123;root, root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; node == stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] &#123; <span class="comment">// First time to visit the parent node</span></span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, node.Val) <span class="comment">// Second time to visit the parent node</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Morris Traversal</p><p>The idea is we make a PreOrder traversal but right node first, and reverse the result. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous := current.Right <span class="comment">// get the right child&#x27;s left most child, and point it back to parent node</span></span><br><span class="line">            <span class="keyword">for</span> previous.Left != <span class="literal">nil</span> &amp;&amp; previous.Left != current &#123;</span><br><span class="line">                previous = previous.Left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">                previous.Left = current</span><br><span class="line">                current = current.Right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Left == current &#123;</span><br><span class="line">                previous.Left = <span class="literal">nil</span></span><br><span class="line">                current = current.Left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h2><p>a. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution</p><p>The idea is passing the level while traversing the tree</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>, result *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(*result) &lt; level &#123;</span><br><span class="line">            *result = <span class="built_in">append</span>(*result, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        (*result)[level - <span class="number">1</span>] = <span class="built_in">append</span>((*result)[level - <span class="number">1</span>], node.Val)</span><br><span class="line">        dfs(node.Left, level + <span class="number">1</span>, result)</span><br><span class="line">        dfs(node.Right, level + <span class="number">1</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(root, <span class="number">1</span>, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h2><p>We just need to reverse the result of BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h2><p>We need to pay attention to the edge case when a node only have one child node.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getDepth(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDepth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(node.Left)</span><br><span class="line">        right := getDepth(node.Right)</span><br><span class="line">        <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + right</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h2><p>a. DFS recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS with queue</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[i]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                node.Left, node.Right = node.Right, node.Left</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. DFS without recursion (PreOrder)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Left, node.Right = node.Right, node.Left</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d. DFS without recursion (PostOrder)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;root, root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; node == stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.Left, node.Right =  node.Right, node.Left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="332-Reconstruct-Itinerary"><a href="#332-Reconstruct-Itinerary" class="headerlink" title="332. Reconstruct Itinerary"></a><a href="https://leetcode.com/problems/reconstruct-itinerary/">332. Reconstruct Itinerary</a></h2><p>We are given a direct graph, and we need to get the node traversal result. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findItinerary</span><span class="params">(tickets [][]<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ticketsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, ticket := <span class="keyword">range</span> tickets &#123;</span><br><span class="line">        ticketsMap[ticket[<span class="number">0</span>]] = <span class="built_in">append</span>(ticketsMap[ticket[<span class="number">0</span>]], ticket[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> ticketsMap &#123;</span><br><span class="line">        sort.Strings(ticketsMap[key])</span><br><span class="line">    &#125;</span><br><span class="line">    path := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> visit <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span></span></span><br><span class="line">    visit = <span class="function"><span class="keyword">func</span><span class="params">(from <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ticketsMap[from]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            to := ticketsMap[from][<span class="number">0</span>]</span><br><span class="line">            ticketsMap[from] = ticketsMap[from][<span class="number">1</span>:]</span><br><span class="line">            visit(to)</span><br><span class="line">        &#125;</span><br><span class="line">        path = <span class="built_in">append</span>(path, from)</span><br><span class="line">    &#125;</span><br><span class="line">    visit(<span class="string">&quot;JFK&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(path) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        path[i], path[j] = path[j], path[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;94-Binary-Tree-Inorder-Traversal&quot;&gt;&lt;a href=&quot;#94-Binary-Tree-Inorder-Traversal&quot; class=&quot;headerlink&quot; title=&quot;94. Binary Tree Inorder Trav</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
    <category term="DFS" scheme="http://blog.beendless.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Heap and Heap Sort</title>
    <link href="http://blog.beendless.com/2021/09/13/Heap-and-Heap-Sort/"/>
    <id>http://blog.beendless.com/2021/09/13/Heap-and-Heap-Sort/</id>
    <published>2021-09-13T19:45:23.000Z</published>
    <updated>2021-09-13T23:17:16.601Z</updated>
    
    <content type="html"><![CDATA[<p>A <code>Heap</code> is a special Tree-based data structure in which the tree is a complete binary tree. Generally, there are two types of <code>Heap</code>: Max-Heap (root node is greater than its child nodes) and Min-Heap (root node is smaller than its child nodes).</p><p>Golang’s standard library shipped with a <a href="https://pkg.go.dev/container/heap"><code>heap</code> container</a>. We can also use a slice to simulate a Heap. Let’s take <code>Max-Heap</code> as an example.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Heap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x)</span><br><span class="line">    index := <span class="built_in">len</span>(*h) - <span class="number">1</span></span><br><span class="line">    parent := (index - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// (index + 1) / 2 - 1, 1 based index node n, it&#x27;s child is 2n and 2n + 1,</span></span><br><span class="line">    <span class="keyword">for</span> parent &gt;= <span class="number">0</span> &amp;&amp; (*h)[index] &gt; (*h)[parent] &#123;</span><br><span class="line">        (*)h[index], (*)h[parent] = (*)h[parent], (*)h[index]</span><br><span class="line">        index = parent</span><br><span class="line">        parent = (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*h) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ret := (*h)[<span class="number">0</span>]</span><br><span class="line">        length := <span class="built_in">len</span>(*h)</span><br><span class="line">        (*h)[<span class="number">0</span>] = (*h)(length - <span class="number">1</span>)</span><br><span class="line">        parent := <span class="number">0</span></span><br><span class="line">        left := <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; length - <span class="number">1</span> &#123;</span><br><span class="line">            child := left</span><br><span class="line">            <span class="keyword">if</span> left + <span class="number">1</span> &lt; length - <span class="number">1</span> &amp;&amp; (*h)[left] &lt; (*h)[left + <span class="number">1</span>]&#123;</span><br><span class="line">                child++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (*h)[parent] &lt; (*h)[child] &#123;</span><br><span class="line">                (*)h[parent], (*)h[child] = (*)h[child], (*)h[parent]</span><br><span class="line">                parent = child</span><br><span class="line">                left = <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *h = (*h)[:length - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Heap</code> is always used to implement the priority queue since it’s search and pop time complexities are both O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex" xmlns="http://www.w3.org/2000/svg" width="5.614ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 2481.2 900" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-2061" d=""></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(278,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(778,0)"></use></g><g data-mml-node="mo" transform="translate(1278,0)"><use data-c="2061" xlink:href="#MJX-1-TEX-N-2061"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1444.7,0)"><g data-mml-node="msub"><g data-mml-node="mi"></g><g data-mml-node="mn" transform="translate(33,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1881.2,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></g></svg></mjx-container>).</p><h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h2><p>A naive implementation will be to get the frequency map , to store the (key, frequency) into a 2D-slice and to sort the matrix with quick sort. Then return the last <code>k</code>th element of the slice.</p><p>a. Bucket Sort solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mapping[v]++</span><br><span class="line">        <span class="keyword">if</span> mapping[v] &gt; max &#123;</span><br><span class="line">            max = mapping[v]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, max + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        buckets[v] = <span class="built_in">append</span>(buckets[v], k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> max &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, buckets[max]...)</span><br><span class="line">        k -= <span class="built_in">len</span>(buckets[max])</span><br><span class="line">        max--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. We can consider the frequency as a priority, so with the help of <code>Max-Heap</code>, we can solve it in  O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 3247.9 900" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-2061" d=""></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(766.7,0)"><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(278,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(778,0)"></use></g><g data-mml-node="mo" transform="translate(2044.7,0)"><use data-c="2061" xlink:href="#MJX-1-TEX-N-2061"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2211.3,0)"><g data-mml-node="msub"><g data-mml-node="mi"></g><g data-mml-node="mn" transform="translate(33,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2647.9,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></g></svg></mjx-container>)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mapping[v]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap := [][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        <span class="comment">// Push into the heap</span></span><br><span class="line">        heap = <span class="built_in">append</span>(heap, [<span class="number">2</span>]<span class="keyword">int</span>&#123;v, k&#125;)</span><br><span class="line">        index := <span class="built_in">len</span>(heap) - <span class="number">1</span></span><br><span class="line">        parent := (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> index &gt; <span class="number">0</span> &amp;&amp; heap[parent][<span class="number">0</span>] &lt; heap[index][<span class="number">0</span>] &#123;</span><br><span class="line">            heap[parent], heap[index] = heap[index], heap[parent]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, heap[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        heap[<span class="number">0</span>] = heap[<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        parent := <span class="number">0</span></span><br><span class="line">        left := <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &#123;</span><br><span class="line">            child := left</span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &amp;&amp; heap[left][<span class="number">0</span>] &lt; heap[left + <span class="number">1</span>][<span class="number">0</span>] &#123;</span><br><span class="line">                child = left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> heap[parent][<span class="number">0</span>] &lt; heap[child][<span class="number">0</span>] &#123;</span><br><span class="line">                heap[parent], heap[child] = heap[child], heap[parent]</span><br><span class="line">                parent = child</span><br><span class="line">                left = <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heap = heap[:<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="692-Top-K-Frequent-Words"><a href="#692-Top-K-Frequent-Words" class="headerlink" title="692. Top K Frequent Words"></a><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a></h2><p>a. Bucket sorting</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(words []<span class="keyword">string</span>, k <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        mapping[word]++</span><br><span class="line">        <span class="keyword">if</span> mapping[word] &gt; max &#123;</span><br><span class="line">            max = mapping[word]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket := <span class="built_in">make</span>([][]<span class="keyword">string</span>, max + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        bucket[value] = <span class="built_in">append</span>(bucket[value], key)</span><br><span class="line">    &#125;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> max &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sort.Strings(bucket[max])</span><br><span class="line">        length := <span class="built_in">len</span>(bucket[max])</span><br><span class="line">        <span class="keyword">if</span> k &lt; length &#123;</span><br><span class="line">            length = k</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, bucket[max][:length]...)</span><br><span class="line">        k -= length</span><br><span class="line">        max--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Max-Heap</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(words []<span class="keyword">string</span>, k <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        mapping[word]++</span><br><span class="line">    &#125;</span><br><span class="line">    heap := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, _ := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        heap = <span class="built_in">append</span>(heap, key)</span><br><span class="line">        index := <span class="built_in">len</span>(heap) - <span class="number">1</span></span><br><span class="line">        parent := (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> index &gt; <span class="number">0</span> &amp;&amp; compareFn(heap[parent], heap[index], mapping) &#123;</span><br><span class="line">            heap[parent], heap[index] = heap[index], heap[parent]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, heap[<span class="number">0</span>])</span><br><span class="line">        heap[<span class="number">0</span>] = heap[<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        index := <span class="number">0</span></span><br><span class="line">        left := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &#123;</span><br><span class="line">            child := left</span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &amp;&amp; compareFn(heap[left], heap[left + <span class="number">1</span>], mapping) &#123;</span><br><span class="line">                child = left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> compareFn(heap[index], heap[child], mapping) &#123;</span><br><span class="line">                heap[index], heap[child] = heap[child], heap[index]</span><br><span class="line">                index = child</span><br><span class="line">                left = <span class="number">2</span> * index + <span class="number">1</span>   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heap = heap[:<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareFn</span><span class="params">(a, b <span class="keyword">string</span>, mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> mapping[b] &lt; mapping[a] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mapping[b] &gt; mapping[a] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Compare(b, a) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A &lt;code&gt;Heap&lt;/code&gt; is a special Tree-based data structure in which the tree is a complete binary tree. Generally, there are two types of</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Bucket Sort" scheme="http://blog.beendless.com/tags/Bucket-Sort/"/>
    
    <category term="Top K Frequent" scheme="http://blog.beendless.com/tags/Top-K-Frequent/"/>
    
    <category term="Heap" scheme="http://blog.beendless.com/tags/Heap/"/>
    
    <category term="Priority Queue" scheme="http://blog.beendless.com/tags/Priority-Queue/"/>
    
  </entry>
  
  <entry>
    <title>Query with Stack</title>
    <link href="http://blog.beendless.com/2021/09/12/Query-with-Stack/"/>
    <id>http://blog.beendless.com/2021/09/12/Query-with-Stack/</id>
    <published>2021-09-12T22:45:23.000Z</published>
    <updated>2021-09-14T00:09:13.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></h2><p>We can simply iterate over all items from the given string and compare the adjacent values each time with the help of stack before pushing the element in. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    bs = <span class="built_in">append</span>(bs, s[<span class="number">0</span>])</span><br><span class="line">    dict := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">byte</span>&#123;</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> v, ok := dict[s[i]]; ok &amp;&amp; <span class="built_in">len</span>(bs) &gt; <span class="number">0</span> &amp;&amp; v == bs[<span class="built_in">len</span>(bs) - <span class="number">1</span>] &#123;</span><br><span class="line">            bs = bs[:<span class="built_in">len</span>(bs) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bs = <span class="built_in">append</span>(bs, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(bs) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h2><p>a. Use stack to iterate the string, similar to the parentheses validation one above.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(bs) &gt; <span class="number">0</span> &amp;&amp; s[i] == bs[<span class="built_in">len</span>(bs) - <span class="number">1</span>]&#123;</span><br><span class="line">            bs = bs[:<span class="built_in">len</span>(bs) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bs = <span class="built_in">append</span>(bs, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Use two pointers</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(s); j++&#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; bs[i] == bs[i - <span class="number">1</span>] &#123;</span><br><span class="line">            i--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs[:i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h2><p>For arithmetic related problems, we usually use stack to solve it. The temporary computation result can be pushed to the top of the stack.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, token := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">        integer, err := strconv.Atoi(token)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums, integer)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            length := <span class="built_in">len</span>(nums)</span><br><span class="line">            x, y := nums[length - <span class="number">2</span>], nums[length - <span class="number">1</span>]</span><br><span class="line">            temp := <span class="number">0</span></span><br><span class="line">            <span class="keyword">switch</span> token &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                temp = x + y</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                temp = x - y</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                temp = x * y</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                temp = x / y</span><br><span class="line">            &#125;</span><br><span class="line">            nums[length - <span class="number">2</span>] = temp</span><br><span class="line">            nums = nums[:length - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h2><p>A naive solution will be store the sliding window items into a slice and calculating the maximum value each time, the time complexity will be O(n * k). We can consider storing the sliding window items in a desending slice(Queue), it always has the maximum value at the top of the queue.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[queue[<span class="built_in">len</span>(queue) - <span class="number">1</span>]] &#123;</span><br><span class="line">            queue = queue[:<span class="built_in">len</span>(queue) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">        <span class="keyword">for</span> queue[<span class="number">0</span>] &lt;= i - k &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, nums[queue[<span class="number">0</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/">71. Simplify Path</a></h2><p><code>Stack</code> is one of the best data structure to solve Path manipulation realted problems. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifyPath</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    dirs := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    paths := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(paths); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> paths[i] == <span class="string">&quot;..&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(dirs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                dirs = dirs[:<span class="built_in">len</span>(dirs) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> paths[i] == <span class="string">&quot;&quot;</span> || paths[i] == <span class="string">&quot;.&quot;</span> || paths[i] == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dirs = <span class="built_in">append</span>(dirs, paths[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + strings.Join(dirs, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;20-Valid-Parentheses&quot;&gt;&lt;a href=&quot;#20-Valid-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;20. Valid Parentheses&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://blog.beendless.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Design a Stack with Queue</title>
    <link href="http://blog.beendless.com/2021/09/12/Design-a-Stack-with-Queue/"/>
    <id>http://blog.beendless.com/2021/09/12/Design-a-Stack-with-Queue/</id>
    <published>2021-09-12T18:45:23.000Z</published>
    <updated>2021-09-12T19:58:05.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><p>We can’t use the similar solution we did for <a href="/2021/09/11/Design-a-Queue-with-Stack/">Design a Queue with Stack</a>. It is because unlike <code>Stack</code>,  moving elements from one <code>Queue</code> to another one won’t change the sequence of elements. We have to pop out all previous elements added into the queue when adding a new element, in this way we can simulate a Stack.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !q.Empty() &#123;</span><br><span class="line">        ret = (*q)[<span class="number">0</span>]</span><br><span class="line">        *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !q.Empty() &#123;</span><br><span class="line">        ret = (*q)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    m *Queue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyStack</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> MyStack&#123;</span><br><span class="line">        &amp;Queue&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.m.Empty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.m.Top()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.m.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*((*s).m))</span><br><span class="line">    s.m.Push(x)</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        s.m.Push(s.m.Pop())</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;225-Implement-Stack-using-Queues&quot;&gt;&lt;a href=&quot;#225-Implement-Stack-using-Queues&quot; class=&quot;headerlink&quot; title=&quot;225. Implement Stack using Q</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Queue" scheme="http://blog.beendless.com/tags/Queue/"/>
    
    <category term="Stack" scheme="http://blog.beendless.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Design a Queue with Stack</title>
    <link href="http://blog.beendless.com/2021/09/11/Design-a-Queue-with-Stack/"/>
    <id>http://blog.beendless.com/2021/09/11/Design-a-Queue-with-Stack/</id>
    <published>2021-09-11T18:45:23.000Z</published>
    <updated>2021-09-12T18:51:12.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></h2><p>Since <code>Queue</code> is <code>FIFO</code> but <code>Stack</code> is <code>FILO</code>. If we need to use <code>Stack</code> to implement a <code>Queue</code>, we need to use at least two <code>Stack</code>s. So we use one stack which only handle <code>Push</code> operations, and another <code>Stack</code> which only handle <code>Pop</code>/<code>Peek</code> operations. And we move elements from the <code>Pop</code> only <code>Stack</code> to the other one when <code>Pop</code>/<code>Peek</code> get called. It will reverse the <code>FILO</code> stack elements sequence after that. So we get a <code>FIFO</code> sequence.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !s.Empty() &#123;</span><br><span class="line">        lastIndex := <span class="built_in">len</span>(*s) - <span class="number">1</span></span><br><span class="line">        ret = (*s)[lastIndex]</span><br><span class="line">        *s = (*s)[:lastIndex]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !s.Empty() &#123;</span><br><span class="line">        ret = (*s)[<span class="built_in">len</span>(*s) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    m, n *Stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        &amp;Stack&#123;&#125;,</span><br><span class="line">        &amp;Stack&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    q.m.Push(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    q.Peek()</span><br><span class="line">    <span class="keyword">return</span> q.n.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.n.Empty() &#123;</span><br><span class="line">        <span class="keyword">for</span> !q.m.Empty() &#123;</span><br><span class="line">            q.n.Push(q.m.Pop())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.n.Peek()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q.m.Empty() &amp;&amp; q.n.Empty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/implement-queue-using-stacks/discuss/64206/Short-O">https://leetcode.com/problems/implement-queue-using-stacks/discuss/64206/Short-O</a>(1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;232-Implement-Queue-using-Stacks&quot;&gt;&lt;a href=&quot;#232-Implement-Queue-using-Stacks&quot; class=&quot;headerlink&quot; title=&quot;232. Implement Queue using S</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Queue" scheme="http://blog.beendless.com/tags/Queue/"/>
    
    <category term="Stack" scheme="http://blog.beendless.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>String Match with KMP Algorithm</title>
    <link href="http://blog.beendless.com/2021/09/09/String-Match-with-KMP-Algorithm/"/>
    <id>http://blog.beendless.com/2021/09/09/String-Match-with-KMP-Algorithm/</id>
    <published>2021-09-10T05:45:23.000Z</published>
    <updated>2021-09-10T06:27:52.409Z</updated>
    
    <content type="html"><![CDATA[<p>Search if a given string pattern (needle) is part of a target string (haystack) is a common problem. The naive approach is to use two nested loops with O(n * m) time complexity. KMP is a better way which has a better performance.</p><p>Two keypoints to implement KMP algorithm:</p><p>a. Generate LPS (Longest common proper Prefix and Suffix ) dictionary<br>b. Use LPS dictionary to identify a better pointer position for next matching instead of steping back.</p><h2 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/">28. Implement strStr()</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    j := <span class="number">-1</span></span><br><span class="line">    lps := getLPS(needle)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j = lps[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == m - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLPS</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    j := <span class="number">-1</span></span><br><span class="line">    lps := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j = lps[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        lps[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="459-Repeated-Substring-Pattern"><a href="#459-Repeated-Substring-Pattern" class="headerlink" title="459. Repeated Substring Pattern"></a><a href="https://leetcode.com/problems/repeated-substring-pattern/">459. Repeated Substring Pattern</a></h2><p>Since we can get the longest common prefix suffix by using KMP. For a string, if its LPS[n - 1] != -1, it means it has common prefix and suffix. So with this in mind, we can check <code>len(s) % (len(s) - lps[-1] + 1)</code>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    lps := getLPS(s)</span><br><span class="line">    <span class="keyword">return</span> lps[n - <span class="number">1</span>] &gt; <span class="number">-1</span> &amp;&amp; n % (n - (lps[n - <span class="number">1</span>] + <span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLPS</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    j := <span class="number">-1</span></span><br><span class="line">    lps := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    lps[<span class="number">0</span>] = j</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j = lps[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        lps[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1392-Longest-Happy-Prefix"><a href="#1392-Longest-Happy-Prefix" class="headerlink" title="1392. Longest Happy Prefix"></a><a href="https://leetcode.com/problems/longest-happy-prefix/">1392. Longest Happy Prefix</a></h2><p>Same as above, we can quickly get the LPS slice and check lps[n-1]</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPrefix</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lps := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">        lps[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">-1</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>] &#123;</span><br><span class="line">                j = lps[j]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j + <span class="number">1</span>] &#123;</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            lps[i] = j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lps[n - <span class="number">1</span>] &gt; <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s[n - (lps[n - <span class="number">1</span>] + <span class="number">1</span>):]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214. Shortest Palindrome"></a><a href="https://leetcode.com/problems/shortest-palindrome/">214. Shortest Palindrome</a></h2><p>a. A naive brute-force solution will be :</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    length := <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, length - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        bs[i], bs[j] = bs[j], bs[i]</span><br><span class="line">    &#125;</span><br><span class="line">    reverted := <span class="keyword">string</span>(bs)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[:n - i] == reverted[i:] &#123;</span><br><span class="line">            <span class="keyword">return</span> reverted[:i] + s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Based on the solution a, <code>s[:n - i] == reverted[i:]</code>, we want to find LPS in <code>s + &#39;#&#39; + reverted</code>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    length := <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, length - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        bs[i], bs[j] = bs[j], bs[i]</span><br><span class="line">    &#125;</span><br><span class="line">    reverted := <span class="keyword">string</span>(bs)</span><br><span class="line">    converted := s + <span class="string">&quot;#&quot;</span> + reverted</span><br><span class="line">    convertedLength := length * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    lps := <span class="built_in">make</span>([]<span class="keyword">int</span>, convertedLength)</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">-1</span>; i &lt; convertedLength; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; converted[i] != converted[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j = lps[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> converted[i] == converted[j + <span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        lps[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s[:n - i] == reverted[i:]</span></span><br><span class="line">    <span class="keyword">return</span> reverted[<span class="number">0</span>: length - (lps[convertedLength - <span class="number">1</span>] + <span class="number">1</span>)] + s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/repeated-substring-pattern/discuss/827070/Python-O(n)-Practice-KMP">https://leetcode.com/problems/repeated-substring-pattern/discuss/827070/Python-O(n)-Practice-KMP</a></li><li><a href="https://www.youtube.com/watch?v=4jY57Ehc14Y&amp;t=857s">https://www.youtube.com/watch?v=4jY57Ehc14Y&amp;t=857s</a></li><li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md</a></li><li><a href="https://leetcode.com/problems/shortest-palindrome/discuss/60113/clean-kmp-solution-with-super-detailed-explanation">https://leetcode.com/problems/shortest-palindrome/discuss/60113/clean-kmp-solution-with-super-detailed-explanation</a></li><li><a href="https://leetcode.com/problems/shortest-palindrome/solution/">https://leetcode.com/problems/shortest-palindrome/solution/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Search if a given string pattern (needle) is part of a target string (haystack) is a common problem. The naive approach is to use two nes</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="String" scheme="http://blog.beendless.com/tags/String/"/>
    
    <category term="KMP" scheme="http://blog.beendless.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Two Pointers</title>
    <link href="http://blog.beendless.com/2021/09/07/Two-Pointers/"/>
    <id>http://blog.beendless.com/2021/09/07/Two-Pointers/</id>
    <published>2021-09-07T07:45:23.000Z</published>
    <updated>2021-09-12T23:25:47.300Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Array Elements In-Placed Removal</li></ol><p>Let’s take a look at a easy problem on Leetcode <a href="https://leetcode.com/problems/remove-element/">27. Remove Element</a>. We will demonstrate how to remove an element from an array without allocating extra space for another array.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j: = <span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] != val &#123;</span><br><span class="line"><span class="keyword">if</span> ret &lt; j &#123;</span><br><span class="line">nums[ret] = nums[j]</span><br><span class="line">&#125;</span><br><span class="line">ret++</span><br><span class="line">&#125;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang Playbook: <a href="https://play.golang.org/p/bhOG7VWIE0-">https://play.golang.org/p/bhOG7VWIE0-</a></p><ol start="2"><li>Squares of a Sorted Array</li></ol><p>Here is another problem on Leetcode <a href="https://leetcode.com/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a>. The straight forward solution will be calculate the squares of the given array with an O(n) loop and then use fast sort to get a result O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 3247.9 900" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-2061" d=""></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(766.7,0)"><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(278,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(778,0)"></use></g><g data-mml-node="mo" transform="translate(2044.7,0)"><use data-c="2061" xlink:href="#MJX-1-TEX-N-2061"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2211.3,0)"><g data-mml-node="msub"><g data-mml-node="mi"></g><g data-mml-node="mn" transform="translate(33,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2647.9,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></g></svg></mjx-container>). So the complexity will be O(n + <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 3247.9 900" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-2061" d=""></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(766.7,0)"><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(278,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(778,0)"></use></g><g data-mml-node="mo" transform="translate(2044.7,0)"><use data-c="2061" xlink:href="#MJX-1-TEX-N-2061"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2211.3,0)"><g data-mml-node="msub"><g data-mml-node="mi"></g><g data-mml-node="mn" transform="translate(33,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2647.9,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></g></svg></mjx-container>). Let’s review the sorted array again. For the squares of the given array, the maximum squred number can only exist on either left end or right end. It means if we have two pointers start at both ends, we can continus comparing the squred number and move the pointer inward, the pointers will meet at the minumum squred number. So the time complexity will be O(n)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, length, length)</span><br><span class="line">    <span class="keyword">for</span> i, j, k := <span class="number">0</span>, length - <span class="number">1</span>, length <span class="number">-1</span>; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        squred_i := nums[i] * nums[i]</span><br><span class="line"> squred_j := nums[j] * nums[j]</span><br><span class="line"> <span class="keyword">if</span> squred_j &gt; squred_i &#123;</span><br><span class="line"> ret[k] = squred_j</span><br><span class="line">            j--</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ret[k] = squred_i</span><br><span class="line">            i++</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang Playbook: <a href="https://play.golang.org/p/h_rFxkg42a4">https://play.golang.org/p/h_rFxkg42a4</a></p><ol start="3"><li>Sliding window</li></ol><p>Generally speaking, a sliding window is a sub-list than runs over an underlying collection. This technique shows how a nested for loop in some array related problems can be converted to a single for loop to reduce the time complexity. Here is a Leetcode problem <a href="https://leetcode.com/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a>. We can easily solve it with two nested loops with O(n<sup>2</sup>) time complexity. Let’s see how we can optimize it with two pointers sliding window.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line">sum += nums[j]</span><br><span class="line"><span class="keyword">for</span> sum &gt;= target &#123;</span><br><span class="line">subLength := j - i + <span class="number">1</span> <span class="comment">// Note: the length of subArray need +1</span></span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span> || subLength &lt; ret &#123;</span><br><span class="line">ret = subLength</span><br><span class="line">&#125;</span><br><span class="line">sum -= nums[i]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang Playbook: <a href="https://play.golang.org/p/EjMpnZJvBaW">https://play.golang.org/p/EjMpnZJvBaW</a></p><p>Since all elements will be visited by the sliding window at most twice (entering or exiting), so the time complexity is O(n) instead of O(n<sup>2</sup>)</p><ol start="4"><li>Reverse a Linked List</li></ol><p>It’s easy to use an additional Linked List to reverse a Linked List. But we can use two pointers to reduce the space complexity down to O(1). Let’s check a LeetCode problem <a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pre *ListNode</span><br><span class="line">cur := head</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">temp := cur.Next</span><br><span class="line">cur.Next = pre</span><br><span class="line">pre = cur</span><br><span class="line">cur = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can also solve it with a recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(pre, node *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;    </span><br><span class="line">    next := node.Next</span><br><span class="line">    node.Next = pre</span><br><span class="line">    <span class="keyword">return</span> helper(node, next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="literal">nil</span>, head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Remove the last Nth node from a Linked List</li></ol><p>The two pointers method can also help us to remove the last Nth node from a Linked List within one iteration. Let’s check LeetCode problem <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/submissions/">19. Remove Nth Node From End of List</a>. Another tip for Linked List node removal, with the help of a dummy node pointing to the head node, it will simplify the process.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;</span><br><span class="line">Next: head,</span><br><span class="line">&#125;</span><br><span class="line">pre, cur := dummy, dummy</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; cur != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">cur = cur.Next</span><br><span class="line"><span class="keyword">if</span> i &gt; n &#123;  <span class="comment">// Since deleting a node, we must get its previous node, so the distance between those two pointers is n + 1 instead of n</span></span><br><span class="line">pre = pre.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pre.Next = pre.Next.Next</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Swap Nodes in Pairs</li></ol><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a> is a similar problem similar to #4 and #5 above. We can quickly solve it with dummy node and two pointers. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;</span><br><span class="line">Next: head,</span><br><span class="line">&#125;</span><br><span class="line">p := dummy</span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; head.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">p.Next = head.Next</span><br><span class="line">temp := p.Next.Next</span><br><span class="line">p.Next.Next = head</span><br><span class="line">head.Next = temp</span><br><span class="line">p = head</span><br><span class="line">head = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip:</strong><br>We can come up with a template here, whenever the solution expects a <code>*ListNode</code> as return value, we should consider using dummy node pointing to the head node.</p><ol start="7"><li>Intersection of Two Linked Lists</li></ol><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a> The key point to solve this problem is to understand the meaning of the intersected Linked List. Based on the examples and description, after the intersected nodes, the two Linked Lists share the same tail nodes. So we just need to find the shorter one’s length N and compare the last N nodes of the given two Linked List.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"> m, n := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"> p, q := headA, headB</span><br><span class="line"> <span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line"> p = p.Next</span><br><span class="line"> m++</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line"> q = q.Next</span><br><span class="line"> n++</span><br><span class="line"> &#125;</span><br><span class="line"> l, s := headA, headB</span><br><span class="line"> k := m - n</span><br><span class="line"> <span class="keyword">if</span> m &lt; n &#123;</span><br><span class="line"> l, s = s, l</span><br><span class="line"> k = n - m</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> l != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> k &lt;= <span class="number">0</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> s == l &#123;</span><br><span class="line"> <span class="keyword">return</span> s</span><br><span class="line"> &#125;</span><br><span class="line"> s = s.Next</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> k--</span><br><span class="line"> &#125;</span><br><span class="line"> l = l.Next</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>Detect Circles I</li></ol><p>A classical usage of two pointers is to detect if a Linked List contains a circle. We can have a faster and a slower pointer. If there’s a circle, the faster pointer should meet the slower one before it reaches to the end of the Linked List. The faster pointer’s moving speed can be set to two times of the slower one’s. <a href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head != <span class="literal">nil</span> &amp;&amp; head.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">f, l := head, head.Next</span><br><span class="line"><span class="keyword">for</span> f != l &#123;</span><br><span class="line"><span class="keyword">if</span> f == <span class="literal">nil</span> || f.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">f = f.Next.Next</span><br><span class="line">l = l.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip:</strong><br>If we make the faster pointer pointing to the head node, the slower pointer pointing to the next node of the head node, and the speed of faster one is 2 times of the slower one. They will meet when we make the first move.</p><ol start="9"><li>Detect Circle’s Starting Node </li></ol><p>Continue to the circle detection problem, how to find the starting node of the circle? Let’s check <a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a>. Given the starting node of the circle A, let’s define below variables:</p><ul><li>x : the distance between the head node and A</li><li>y : the distance between A and the met node P</li><li>z : the distance between the met node P and A</li></ul><p>Since faster node’s speed is two times of the slower one. We can get <code>(x + y) * 2 = n * (y + z) + (x + y)</code> =&gt; <code>x = n * (y + z) - y</code> =&gt; <code>x = (n - 1) * (y + z) + z</code> . It means after those two pointers meet at P,  if the slower pointer continues moving to A, the moved distance will be the same length if we move a new pointer from head to A. More information you can get from (<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md</a>)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">f, s := head, head</span><br><span class="line"><span class="keyword">for</span> f != <span class="literal">nil</span> &amp;&amp; f.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">f = f.Next.Next</span><br><span class="line">s = s.Next</span><br><span class="line"><span class="keyword">if</span> f == s &#123;</span><br><span class="line">t := head</span><br><span class="line"><span class="keyword">for</span> t != s &#123;</span><br><span class="line">t = t.Next</span><br><span class="line">s = s.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>3 Sum</li></ol><p>For LeetCode questtion <a href="https://leetcode.com/problems/3sum/">15. 3Sum</a>, the brute-force solution’s time complexity is at least O(n^3). We can convert it to a two sum problem in side of a loop. We can compare the adjacent elements to remove the duplicated solution.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i++ &#123;</span><br><span class="line">n1 = nums[i]</span><br><span class="line"><span class="keyword">if</span> n1 &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; n1 == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">j := i + <span class="number">1</span></span><br><span class="line">k := length - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">n2 := nums[j]</span><br><span class="line">n3 := nums[k]</span><br><span class="line">t := n1 + n2 + n3</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;n1, n2, n3&#125;)</span><br><span class="line">while j &lt; k &amp;&amp; n2 == nums[j] &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">while k &gt; j &amp;&amp; n3 == nums[k] &#123;</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> t &lt; <span class="number">0</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>4 Sum</li></ol><p>Similar to 3 Sum, we can solve <a href="https://leetcode.com/problems/4sum/">18. 4Sum</a> with two pointers.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++ &#123;</span><br><span class="line">n1 := nums[i]</span><br><span class="line"><span class="keyword">if</span> target &gt;= <span class="number">0</span> &amp;&amp; n1 &gt; target &#123; <span class="comment">// Note: if target is negative, we can&#x27;t break the loop</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; n1 == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++ &#123;</span><br><span class="line">n2 := nums[j]</span><br><span class="line"><span class="keyword">if</span> j &gt; i + <span class="number">1</span> &amp;&amp; n2 == nums[j - <span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := j + <span class="number">1</span></span><br><span class="line">l := length - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k &lt; l &#123;</span><br><span class="line">n3 := nums[k]</span><br><span class="line">n4 := nums[l]</span><br><span class="line">t := n1 + n2 + n3 + n4</span><br><span class="line"><span class="keyword">if</span> t == target &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;n1, n2, n3, n4&#125;)</span><br><span class="line"><span class="keyword">for</span> k &lt; l &amp;&amp; n3 == nums[k] &#123;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> l &gt; k &amp;&amp; n4 == nums[l] &#123;</span><br><span class="line">l--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t &lt; <span class="number">0</span> &#123;</span><br><span class="line">k++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li><a href="https://leetcode.com/problems/reverse-string/">344. Reverse String</a></li></ol><p>We can reverse a string with O(1) extra space by using two pointers method.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, length - <span class="number">1</span>; i &lt; j; &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li><a href="https://leetcode.com/problems/reverse-string-ii/">541. Reverse String II</a></li></ol><p>Note, since the string in Go is immutable, if we need to manipulate a string’s contenet, we need to convert it to a byte slice first. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">length := <span class="built_in">len</span>(bs)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i += <span class="number">2</span> * k &#123;</span><br><span class="line"><span class="keyword">if</span> i + k &lt; length &#123;</span><br><span class="line">reverse(bs[i:i+k])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reverse(bs[i:])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, length - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">URL Encoding</a></li></ol><p>Besides the brute-force solution, we can solve it with O(1) space if the string is mutable.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line">bs := []<span class="keyword">byte</span>(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">n += <span class="number">2</span> <span class="comment">// Replace &#x27; &#x27; with &#x27;%20&#x27;, so we will need 2*k additional bytes</span></span><br><span class="line">&#125;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">bs = <span class="built_in">append</span>(bs, temp...)</span><br><span class="line"><span class="keyword">for</span> i, j := length - <span class="number">1</span>, length + n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; &#123;</span><br><span class="line"><span class="keyword">if</span> bs[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">bs[j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">bs[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">bs[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span></span><br><span class="line">j -= <span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bs[j] = bs[i]</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>15.<a href="https://leetcode.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></p><p>A quickly solution will be we split the string with regexp to a list, then construct a new string by traversing the list from the end to the beginning. But it will take O(n) space. Let’s solve it with a in-place method (assume the string is mutable). </p><p>a. Use two pointers (fast/slow) to trim the spaces at the beginning, in this step, the fast pointer will stop at the first non-space character.<br>b. Start shifting the slice to left if the fast pointer and its previous element are space. So the slow and the fast pointers both moving, and the slower one will stop at the last non-space character or the only space left in the new string (if there are more than one adjacent spaces at the end of the original string)<br>c. Remove the spaces at the end<br>d. Reverse the whole new string<br>e. Reverse the words one by one</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    length := <span class="built_in">len</span>(bs)</span><br><span class="line">    s, f := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// move faster pointer to the first non-space character</span></span><br><span class="line">    <span class="keyword">for</span> ; f &lt; length &amp;&amp; bs[f] == <span class="string">&#x27; &#x27;</span>; f++ &#123;&#125;</span><br><span class="line">    <span class="comment">// merge the adjacent spaces into one, if we have two adjacent spaces, move both the fast amd slow pointers to shift the slice to left</span></span><br><span class="line">    <span class="keyword">for</span> ; f &lt; length; f++ &#123;</span><br><span class="line">    <span class="keyword">if</span> f &gt; <span class="number">1</span> &amp;&amp; bs[f] == <span class="string">&#x27; &#x27;</span> &amp;&amp; bs[f - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    bs[s] = bs[f]</span><br><span class="line">    s++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Till now, the slow pointer is pointing to the end of non-space character. So we just need to remove the tailing space</span></span><br><span class="line">    <span class="keyword">if</span> s &gt; <span class="number">1</span> &amp;&amp; bs[s - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">    bs = bs[:s - <span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bs = bs[:s]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Two pinters to reverse the string</span></span><br><span class="line">    reverse(bs)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bs);&#123;</span><br><span class="line">    <span class="keyword">for</span> t := i; t &lt; <span class="built_in">len</span>(bs) &amp;&amp; bs[t] != <span class="string">&#x27; &#x27;</span>; t++ &#123;&#125;</span><br><span class="line">    reverse(bs[i:t])</span><br><span class="line">    i = t</span><br><span class="line">    i++ <span class="comment">// Skip space</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, length - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="16"><li>(Swap string’s left and right sides)[<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/]">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/]</a></li></ol><p>We can simply reconstruct the string with O(n) space. but if we want to use O(1) space if the string is mutable, two pointers reverse can help us to make it done.</p><p>a. Reverse the first n elements<br>b. Reverse the elements after n<br>c. Reverse the whole slice</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLeftWords</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    reverse(bs[<span class="number">0</span>:n])</span><br><span class="line">    reverse(bs[n:])</span><br><span class="line">    reverse(bs)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, length - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="17"><li><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">length := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; i &lt; length; j++ &#123;</span><br><span class="line">bs[i] = bs[j]</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; bs[i] == bs[i - <span class="number">1</span>] &#123;</span><br><span class="line">i--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(bs[:i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;Array Elements In-Placed Removal&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s take a look at a easy problem on Leetcode &lt;a href=&quot;https://leetcode.com/proble</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Array" scheme="http://blog.beendless.com/tags/Array/"/>
    
    <category term="Linked List" scheme="http://blog.beendless.com/tags/Linked-List/"/>
    
    <category term="String" scheme="http://blog.beendless.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Common Items Quick Search with Array and HashMap</title>
    <link href="http://blog.beendless.com/2021/09/06/Common-Items-Quick-Search-with-Array-and-HashMap/"/>
    <id>http://blog.beendless.com/2021/09/06/Common-Items-Quick-Search-with-Array-and-HashMap/</id>
    <published>2021-09-07T04:45:23.000Z</published>
    <updated>2021-09-07T04:38:59.843Z</updated>
    
    <content type="html"><![CDATA[<p>Usually when you get a problem about searching the common items between multiple strings, the brute-force solution’s time complexity is usually too high. We can use hashmap to lower the time complexity.</p><h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/">242. Valid Anagram</a></h2><p>If we go with brute-force solution, the time complexity will be <code>m * n</code>. Let’s try with hashmap.</p><p>a. Regular hashmap</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123; <span class="comment">// edge case quick solution</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; <span class="comment">// Note: in Golang, when using range to iterate a string, you will get rune instead of byte</span></span><br><span class="line"><span class="keyword">if</span> _, ok := cache[s[i]]; ok &#123;</span><br><span class="line">cache[s[i]]++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cache[s[i]] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> t &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := cache[t[i]]; ok &#123;</span><br><span class="line">cache[t[i]]--</span><br><span class="line"><span class="keyword">if</span> cache[t[i]] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Use array to simulate hashmap</p><p>Since we know that the input strings only contain lowercase English letters ([a-z], fixed size, continued integers, sorted), it means we can use a fixed size array to cache the frequency of the string items. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cache [<span class="number">26</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">cache[s[i] - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> t &#123;</span><br><span class="line">index := t[i] - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">cache[index]--</span><br><span class="line"><span class="keyword">if</span> cache[index] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1002-Find-Common-Characters"><a href="#1002-Find-Common-Characters" class="headerlink" title="1002. Find Common Characters"></a><a href="https://leetcode.com/problems/find-common-characters/">1002. Find Common Characters</a></h2><p>Similar to the solutions above, we can easily get the solution. Note, since this time, we need to get the frequency of characters in each string, we have to use a two dimensional array.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commonChars</span><span class="params">(words []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> cache[][<span class="number">26</span>]<span class="keyword">int</span></span><br><span class="line">length := <span class="built_in">len</span>(words)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="keyword">var</span> letters [<span class="number">26</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> item &#123;</span><br><span class="line">letters[item[i] - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">&#125;</span><br><span class="line">cache = <span class="built_in">append</span>(cache, letters)</span><br><span class="line">&#125;</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">26</span>; i++ &#123;</span><br><span class="line">min := cache[<span class="number">0</span>][i]</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> min &gt; cache[j][i] &#123;</span><br><span class="line">min = cache[j][i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; min &gt; <span class="number">0</span>; min-- &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, <span class="keyword">string</span>(i + <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip:</strong></p><p>If the common items searching problem has keyworks like <code>frequency</code>, <code>lowercase</code> English characters, we can try if hashmap + array method</p><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.com/problems/ransom-note/">383. Ransom Note</a></h2><p>Based on the tip above, we can quickly solve it with:</p><p>a. Regular hashmap</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">length := <span class="built_in">len</span>(magazine)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">cache[magazine[i]]++</span><br><span class="line">&#125;</span><br><span class="line">length = <span class="built_in">len</span>(ransomNote)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">cache[ransomNote[i]]--</span><br><span class="line"><span class="keyword">if</span> cache[ransomNote[i]] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Array based hashmap</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">cache := <span class="built_in">make</span>([<span class="number">26</span>]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">length := <span class="built_in">len</span>(magazine)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">cache[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">&#125;</span><br><span class="line">length = <span class="built_in">len</span>(ransomNote)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">cache[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line"><span class="keyword">if</span> cache[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><p>Getting two array intersection, we can try <code>Set</code> or with the help of hashmap </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">cache[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> v, ok := cache[i]; ok &amp;&amp; v &gt; <span class="number">0</span> &#123;</span><br><span class="line">cache[i] = <span class="number">0</span></span><br><span class="line">result = <span class="built_in">append</span>(result, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h2><p>Using hashmap can solve two-sum in <code>O(n)</code> complexity.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> index, ok := cache[target - v]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, index&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache[v] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a><a href="https://leetcode.com/problems/4sum-ii/">454. 4Sum II</a></h2><p>Similar to two sum problem, we can convert 4 sum ii problem to a two sum problem.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, nums3 []<span class="keyword">int</span>, nums4 []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">result := <span class="number">0</span></span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">// Since we can calculate the duplicated result, map value needs to be an integer</span></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line"><span class="keyword">for</span> _, j := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">cache[i + j]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> nums3 &#123;</span><br><span class="line"><span class="keyword">for</span> _, j := <span class="keyword">range</span> nums4 &#123;</span><br><span class="line">result += cache[-i-j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.com/problems/happy-number/">202. Happy Number</a></h2><p>Since we need to detect if <code>it loops endlessly in a circle</code>, it’s better to use a hashmap (set).</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">isHappyNumber := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">s := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">t := n % <span class="number">10</span></span><br><span class="line">s += t * <span class="number">5</span></span><br><span class="line">n = n / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simulate a set by flaging the calculated number before to detect the circle</span></span><br><span class="line"><span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !cache[n] &#123;</span><br><span class="line">n, cache[n] = isHappyNumber(n), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Usually when you get a problem about searching the common items between multiple strings, the brute-force solution’s time complexity is u</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Array" scheme="http://blog.beendless.com/tags/Array/"/>
    
    <category term="HashMap" scheme="http://blog.beendless.com/tags/HashMap/"/>
    
  </entry>
  
</feed>
