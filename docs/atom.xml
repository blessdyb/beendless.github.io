<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Beendless ~ 快节奏,慢生活,无止境</title>
  
  <subtitle>Move Fast, Live Happily, With No End</subtitle>
  <link href="http://blog.beendless.com/atom.xml" rel="self"/>
  
  <link href="http://blog.beendless.com/"/>
  <updated>2021-10-07T18:45:47.813Z</updated>
  <id>http://blog.beendless.com/</id>
  
  <author>
    <name>Yabo Du &amp; Yanrong Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dynamic Programming I</title>
    <link href="http://blog.beendless.com/2021/10/06/Dynamic%20Programming%20I/"/>
    <id>http://blog.beendless.com/2021/10/06/Dynamic%20Programming%20I/</id>
    <published>2021-10-07T05:00:24.000Z</published>
    <updated>2021-10-07T18:45:47.813Z</updated>
    
    <content type="html"><![CDATA[<p>Dynamic Programming (commonly referred to as DP) is an algorithmic technique for solving a problem by recursively breaking it down into simpler subproblems and using the fact that the optimal solution to the overall problem depends upon the optimal solution to it’s individual subproblems. Here is an interesting Quora question <a href="https://www.quora.com/How-should-I-explain-dynamic-programming-to-a-4-year-old">How should I explain dynamic programming to a 4-year-old?</a>.</p><h2 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a><a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    fib0 := fib(n - <span class="number">2</span>)</span><br><span class="line">    fib1 := fib(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> fib0 + fib1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic Programming</p><p>State transition function: <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></h2><p>State transition function: <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746. Min Cost Climbing Stairs"></a><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">746. Min Cost Climbing Stairs</a></h2><p>Denote dp[i] to the cost we want to step away from stair ith,  so the state transition function: <code>min(dp[i - 1], dp[i - 2]) + cost[i]</code>. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dp[n - <span class="number">1</span>], dp[n - <span class="number">2</span>]) <span class="comment">// To reach to stair n, we can step away from n - 1 or n - 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Another way to think about it. If we denote dp[i] as the cost to reach to ith stair, the state transition function is <code>dp[n] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></h2><p>It’s easy to get the state transition function <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code> . Note for the special case first line and first row, the value is 1.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Based on the state transition function, dp[i][j] is defined only by two values, so we can optimize the space complexity from O(m * n) to O(n) by using a new state transition function <code>dp[j] = dp[j] + dp[j - 1]</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a></h2><p>This is a similar problem to #62. The only difference is that we need to reset the path sum to 0 if there’s an obstacle at the coordinate.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    n := <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] = <span class="number">1</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>&#123;</span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a><a href="https://leetcode.com/problems/integer-break/">343. Integer Break</a></h2><p>The key point of solving this problem is to get the state transition function. There are two cases:</p><ol><li>we can split the number i into two i - j and j</li><li>we can split the number into more than two, this case we can reuse the cached value from dp array.  dp[i - j] * j </li></ol><p>So the state transition function <code>dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            two := j * (i - j)</span><br><span class="line">            twoMore := j * dp[i - j]</span><br><span class="line">            dp[i] = max(dp[i], max(two, twoMore))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dynamic Programming (commonly referred to as DP) is an algorithmic technique for solving a problem by recursively breaking it down into s</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://blog.beendless.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Problems - III</title>
    <link href="http://blog.beendless.com/2021/10/06/Greedy%20%20Problems%20III/"/>
    <id>http://blog.beendless.com/2021/10/06/Greedy%20%20Problems%20III/</id>
    <published>2021-10-07T04:55:24.000Z</published>
    <updated>2021-10-07T04:58:31.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a></h2><p>Similar to other sgement related problems. The first thing we need to do is to sort the slice. Once we have a sorted segment slice, we can iterate over all items and merge them. Note there is one edge case we need to cover after the iteration, either we merged all segments into one or the last one can’t be merged into the previous segment. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[a][<span class="number">0</span>] &lt; intervals[b][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    start := intervals[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> end &lt; intervals[i][<span class="number">0</span>] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;start, end&#125;)</span><br><span class="line">            start = intervals[i][<span class="number">0</span>]</span><br><span class="line">            end = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> end &lt; intervals[i][<span class="number">1</span>] &#123;</span><br><span class="line">            end = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;start, end&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a><a href="https://leetcode.com/problems/partition-labels/">763. Partition Labels</a></h2><h2 id="738-Monotone-Increasing-Digits"><a href="#738-Monotone-Increasing-Digits" class="headerlink" title="738. Monotone Increasing Digits"></a><a href="https://leetcode.com/problems/monotone-increasing-digits/">738. Monotone Increasing Digits</a></h2><h2 id="968-Binary-Tree-Cameras"><a href="#968-Binary-Tree-Cameras" class="headerlink" title="968. Binary Tree Cameras"></a><a href="https://leetcode.com/problems/binary-tree-cameras/">968. Binary Tree Cameras</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;56-Merge-Intervals&quot;&gt;&lt;a href=&quot;#56-Merge-Intervals&quot; class=&quot;headerlink&quot; title=&quot;56. Merge Intervals&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/p</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Problems - II</title>
    <link href="http://blog.beendless.com/2021/10/05/Greedy%20%20Problems%20II/"/>
    <id>http://blog.beendless.com/2021/10/05/Greedy%20%20Problems%20II/</id>
    <published>2021-10-05T17:25:24.000Z</published>
    <updated>2021-10-07T04:35:57.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="1005. Maximize Sum Of Array After K Negations"></a><a href="https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/">1005. Maximize Sum Of Array After K Negations</a></h2><p>To get a maximum sum, we need to convert as many negative numbers to positive ones. If there is still an odd times of converting number left, we just need to convert the smallest positive number to a negative one</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; k &amp;&amp; i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            nums[i] = -nums[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i &lt; k &amp;&amp; (k - i) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        sort.Ints(nums)</span><br><span class="line">        nums[<span class="number">0</span>] = -nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        result += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a><a href="https://leetcode.com/problems/gas-station/">134. Gas Station</a></h2><p>Several cases:<br>    1) If the total amount of gas is less than the total amount of the cost, we can’t make a round trip<br>    2) Given an arbitrary start point i, and at i we have gas[i] in the tank. Let’s start at this point and accumulate the gas we left in the tank. If at point i + k the acculation is negative, it means we can’t reach from any point in beteeen [i, i + k - 1) to point k. So we can quickly start from i + k + 1 instead of i + 1.</p><p>So the local optimal solution for a given start point is from this starting point, we are making a round trip, the debet won’t be negative. If it’s negative, we need to start after the negative point. This can lead to a global optimal solution.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    debet := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gas); i++ &#123;</span><br><span class="line">        sum += gas[i] - cost[i]</span><br><span class="line">        debet += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> debet &lt; <span class="number">0</span> &#123;</span><br><span class="line">            debet = <span class="number">0</span></span><br><span class="line">            result = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.com/problems/candy/">135. Candy</a></h2><p>Since the rating only have effect to neighbour candy distribution. We can start from one end to distribution the candy once, to make sure all children are happy when looking to their right. Then we make another round from the other end.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(ratings)</span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    candies[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>] &#123;</span><br><span class="line">            candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candies[i] = <span class="number">1</span>   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>] &amp;&amp; candies[i] &lt; candies[i + <span class="number">1</span>] + <span class="number">1</span> &#123;</span><br><span class="line">            candies[i] = candies[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        result += candies[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="860-Lemonade-Change"><a href="#860-Lemonade-Change" class="headerlink" title="860. Lemonade Change"></a><a href="https://leetcode.com/problems/lemonade-change/">860. Lemonade Change</a></h2><p>A greedy solution will be if we have <sup>10, we provide </sup>10 to customers who pay with $20.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lemonadeChange</span><span class="params">(bills []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    five := <span class="number">0</span></span><br><span class="line">    ten := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bills); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> bills[i] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            five++</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            ten++</span><br><span class="line">            <span class="keyword">if</span> five &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                five --</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">if</span> ten == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> five &lt; <span class="number">3</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                five -= <span class="number">3</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ten &gt; <span class="number">0</span> &#123;</span><br><span class="line">                ten--</span><br><span class="line">                <span class="keyword">if</span> five == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                five--</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h2><p>Since there are to demensions, and the demension k depends on h, the idea is we sort the given slice by h as the primary order, k as the secondary order. After that, we use the insert sorting algorithm to insert all slice items one by one based on the k value to a new slice.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="comment">// order by h desc, order by k asc</span></span><br><span class="line">        <span class="keyword">if</span> people[a][<span class="number">0</span>] == people[b][<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> people[a][<span class="number">1</span>] &lt; people[b][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[a][<span class="number">0</span>] &gt; people[b][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, p)</span><br><span class="line">        <span class="built_in">copy</span>(result[p[<span class="number">1</span>] + <span class="number">1</span>:], result[p[<span class="number">1</span>]:])</span><br><span class="line">        result[p[<span class="number">1</span>]] = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloons</a></h2><p>A greedy solution is we choose the shoot point which is the most line segments overlaped as a local optimal, it also leads to a global optimal solution. For example, we have four segments as below. If we sort them by the start point, we can easily get a first point should be between e ~ b. It means we iterate all segments, if the current segment’s start point is no great than the previous one’s end point, we can merge those two by reseting the current one’s end point to the minimum number between itself and the previous one’s end point.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|--------------|</span><br><span class="line">a              b</span><br><span class="line">    |-----------------|</span><br><span class="line">    c                 d</span><br><span class="line">       |---------|</span><br><span class="line">       e         f</span><br><span class="line">                   |---------|</span><br><span class="line">                   g         h</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> points[a][<span class="number">0</span>] &lt; points[b][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            result++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> points[i][<span class="number">1</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            points[i][<span class="number">1</span>] = points[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a><a href="https://leetcode.com/problems/non-overlapping-intervals/">435. Non-overlapping Intervals</a></h2><p>This one is a similar problem as #452. An intuition to solve this kind of problem is sort if first. Since all line segments have two points, we have two choices to sort it. The local optimal to find the interval is the end of current segment should have a distance between the next one’s start point. With this in mind, we can quickly get the total of intervals. So if we sort by the end point, we can iterate from left to right. Otherwise, we need to reverse the iteration order.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[a][<span class="number">1</span>] &lt; intervals[b][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> end &lt;= intervals[i][<span class="number">0</span>] &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1005-Maximize-Sum-Of-Array-After-K-Negations&quot;&gt;&lt;a href=&quot;#1005-Maximize-Sum-Of-Array-After-K-Negations&quot; class=&quot;headerlink&quot; title=&quot;1005</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>JumpGame  Problems</title>
    <link href="http://blog.beendless.com/2021/10/03/JumpGame%20%20Problems/"/>
    <id>http://blog.beendless.com/2021/10/03/JumpGame%20%20Problems/</id>
    <published>2021-10-04T05:05:24.000Z</published>
    <updated>2021-10-06T01:29:23.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/">55. Jump Game</a></h2><p>a. Greedy solutions</p><p>At each step, a greedy jump can give us the local optimal furthest solution. Our global solution can be found in if we always take the greedy jump.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    distance := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= distance; i++ &#123; <span class="comment">// Note: here we use distance to control which items we can check</span></span><br><span class="line">        <span class="keyword">if</span> distance &lt; i + nums[i] &#123;</span><br><span class="line">            distance = i + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> distance &gt;= length - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; length; j++ &#123;</span><br><span class="line">                dp[i + j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a></h2><p>a. Greedy solution</p><p>Each time, we will jump to a position which can make us future jumping even further. And each jump will resolve to a coverage range as below, so the total jump steps will be the sum of times we reach to the edge of the coverge range.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 2 | 3 | 1 | 1 | 4 | 5 | 1 | 2 |</span><br><span class="line"></span><br><span class="line">|----------&gt;|</span><br><span class="line">    |--------------&gt;|</span><br><span class="line"></span><br><span class="line">                |--------------&gt;|</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> max &lt; nums[i] + i &#123;  <span class="comment">// Get the next coverage edge</span></span><br><span class="line">            max = nums[i] + i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == end &#123;           <span class="comment">// Switch to the next range with a jump</span></span><br><span class="line">            end = max</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i + j] == <span class="number">-1</span> &#123;</span><br><span class="line">                dp[i + j] = dp[i] + <span class="number">1</span>   </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> dp[i + j] &gt; dp[i] + <span class="number">1</span> &#123;</span><br><span class="line">                dp[i + j] = dp[i] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/">1306. Jump Game III</a></h2><p>The keypoint here is during the traversal of the recursive, we don’t get lost in a infinite loop. So we need to remember all of the visted nodes in a hash.</p><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    reachedNodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">var</span> jump <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    jump = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reachedNodes[index] &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        reachedNodes[index] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> index - arr[index] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            jump(index - arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index + arr[index] &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">            jump(index + arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jump(start)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Queue traversal solution.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    reachedNodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;start&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        index := queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        reachedNodes[index] = <span class="literal">true</span></span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> index + arr[index] &lt; length &amp;&amp; !reachedNodes[index + arr[index]] &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, index + arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index - arr[index] &lt; length &amp;&amp; !reachedNodes[index - arr[index]] &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, index - arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a><a href="https://leetcode.com/problems/jump-game-iv/">1345. Jump Game IV</a></h2><p>This is a classical tree traversal with BFS problem. From each array index we can jump to multiple elements simoteniously, those nextstep elements can be consiered as the tree node’s child nodes. So we jump to all nodes’s children nodes at once which can be considered as one jump (BFS). Since the same value of the nodes can jump to each other, we have to mark the nodes values which have been pushed to the queue to make sure we don’t push the same nodes back to the queue (even we have a visited flag, we can easily run out of memory without another same number flag under this edge case if we have 1000 same value nodes in the slice). </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minJumps</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    jumpIndexes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        jumpIndexes[v] = <span class="built_in">append</span>(jumpIndexes[v], i)</span><br><span class="line">    &#125;</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    queue[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">    sameNumberVisited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>) <span class="comment">// Have a flag is one thing, another solution is to remove the sameNumber key from the jumpIndexes hashmap.</span></span><br><span class="line">    n := <span class="built_in">len</span>(queue)</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            index := queue[i]</span><br><span class="line">            <span class="keyword">if</span> index == length - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !visited[index] &#123;</span><br><span class="line">                visited[index] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> index - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[index - <span class="number">1</span>]&#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, index - <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> index + <span class="number">1</span> &lt; length &amp;&amp; !visited[index + <span class="number">1</span>] &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, index + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> !sameNumberVisited[arr[index]] &#123;</span><br><span class="line">                    sameNumberVisited[arr[index]] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">for</span> _, v := <span class="keyword">range</span> jumpIndexes[arr[index]] &#123;</span><br><span class="line">                        <span class="keyword">if</span> !visited[v] &#123;</span><br><span class="line">                            queue = <span class="built_in">append</span>(queue, v)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        result++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1340-Jump-Game-V"><a href="#1340-Jump-Game-V" class="headerlink" title="1340. Jump Game V"></a><a href="https://leetcode.com/problems/jump-game-v/">1340. Jump Game V</a></h2><p>To resolve this problem, we need to understand <code> you can only jump from index i to index j if arr[i] &gt; arr[j] and arr[i] &gt; arr[k] for all indices k between i and j (More formally min(i, j) &lt; k &lt; max(i, j)).</code>. Let’s say we stand at index i, and jumping from i - 1, i + 1 until i - d, i + d inside of for loops. We need to break the loop if we find a k between [i-d, i) or (i, i + d] which makes arr[k] &gt;= arr[i].</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxJumps</span><span class="params">(arr []<span class="keyword">int</span>, d <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> jump <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    jump = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[index] == <span class="number">0</span> &#123;</span><br><span class="line">            dp[index] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i := index - <span class="number">1</span>; i &gt;= max(<span class="number">0</span>, index - d) &amp;&amp; arr[i] &lt; arr[index]; i-- &#123;</span><br><span class="line">                dp[index] = max(dp[index], jump(i) + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt;= min(length - <span class="number">1</span>, index + d) &amp;&amp; arr[i] &lt; arr[index]; i++ &#123;</span><br><span class="line">                dp[index] = max(dp[index], jump(i) + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        dp[i] = jump(i)</span><br><span class="line">        result = max(dp[i], result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1696-Jump-Game-VI"><a href="#1696-Jump-Game-VI" class="headerlink" title="1696. Jump Game VI"></a><a href="https://leetcode.com/problems/jump-game-vi/">1696. Jump Game VI</a></h2><p>A naive idea is to iterate over all nodes, so the worse time complexity could be O(n * k) [K = maxJump - minJump] which most likely will cause a TLE issue. This one can be considered as a classic <a href="/tags/Sliding-Window/">sliding window</a> maximum problem. Since dp[i] = nums[i] + max(dp[i - k], … , dp[i - 1]). We just need to maintain the maximum dp value in the sliding window during the iteration.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">01010101010101011111</span><br><span class="line"></span><br><span class="line">|---------(i)------|</span><br><span class="line">    |-----&gt;|</span><br><span class="line">    i-k    i-1</span><br><span class="line">|----------(i + 1)------|</span><br><span class="line">     |-----&gt;|</span><br><span class="line">     i-k+1  i</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxResult</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;      <span class="comment">// stores the dp indexes of the sliding window items</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        maxSumIndex := queue[<span class="number">0</span>]</span><br><span class="line">        dp[i] = nums[i] + dp[maxSumIndex]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; dp[queue[<span class="built_in">len</span>(queue) - <span class="number">1</span>]] &lt;= dp[i] &#123; <span class="comment">// sliding window queue contains all values in a desending order</span></span><br><span class="line">            queue = queue[:<span class="built_in">len</span>(queue) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; i - queue[<span class="number">0</span>] &gt;= k &#123;  <span class="comment">// remove the index which is going to out of the window</span></span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, dp[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1871-Jump-Game-VII"><a href="#1871-Jump-Game-VII" class="headerlink" title="1871. Jump Game VII"></a><a href="https://leetcode.com/problems/jump-game-vii/">1871. Jump Game VII</a></h2><p>Same as the above one, a naive dp will get a TLE. A keypoint to solve this problem is we need to avoid the duplicated node visiting. One way is we can use a hashmap to note all visited elements. Another method is that we can bypass the overlap like below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01010101010101011111</span><br><span class="line">  |---------&gt;|</span><br><span class="line">  1          2</span><br><span class="line">    |---------&gt;|</span><br><span class="line">    3          4</span><br></pre></td></tr></table></figure><p>The first jump range is 1 ~ 2, the second is 3 ~ 4, here the range 3 ~ 2 doesn’t need to be visited again. With this in mind, we can use tree-like traversal solution with queue or two pointers sliding window to fix this issue.</p><p>a. Queue with traversal solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(s <span class="keyword">string</span>, minJump <span class="keyword">int</span>, maxJump <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    edge := <span class="number">0</span></span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        index := queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        left := index + minJump</span><br><span class="line">        right := min(length - <span class="number">1</span>, index + maxJump)</span><br><span class="line">        <span class="keyword">for</span> i := max(edge + <span class="number">1</span>, left); i &lt;= right; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; !visited[i]&#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edge = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Two pointers</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(s <span class="keyword">string</span>, minJump <span class="keyword">int</span>, maxJump <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s[length - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">                <span class="keyword">return</span> b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        canVisit := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">        canVisit[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        edge := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= edge &amp;&amp; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> canVisit[i] &#123;</span><br><span class="line">                left := i + minJump</span><br><span class="line">                right := min(length - <span class="number">1</span>, i + maxJump)</span><br><span class="line">                <span class="keyword">for</span> j := max(left, edge + <span class="number">1</span>); j &lt;= right; j++ &#123;</span><br><span class="line">                    <span class="keyword">if</span> s[j] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                        canVisit[j] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">if</span> j == length - <span class="number">1</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                edge = right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;55-Jump-Game&quot;&gt;&lt;a href=&quot;#55-Jump-Game&quot; class=&quot;headerlink&quot; title=&quot;55. Jump Game&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
    <category term="BFS" scheme="http://blog.beendless.com/tags/BFS/"/>
    
    <category term="DFS" scheme="http://blog.beendless.com/tags/DFS/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
    <category term="JumpGame" scheme="http://blog.beendless.com/tags/JumpGame/"/>
    
    <category term="Dynamic Programming" scheme="http://blog.beendless.com/tags/Dynamic-Programming/"/>
    
    <category term="Two Pointers" scheme="http://blog.beendless.com/tags/Two-Pointers/"/>
    
    <category term="Sliding Window" scheme="http://blog.beendless.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Stock Exchange Problems</title>
    <link href="http://blog.beendless.com/2021/10/03/Stock%20Exchange%20Problems/"/>
    <id>http://blog.beendless.com/2021/10/03/Stock%20Exchange%20Problems/</id>
    <published>2021-10-04T01:25:24.000Z</published>
    <updated>2021-10-07T04:41:41.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><p>a. Greedy solution</p><p>To gian the maximum amount of profit, we just need to accumulate the position profits if we buy it on the previous day and sell it on the next day.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        profit := prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> profit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result += profit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Peak &amp; Valley solution</p><p>A naive approach is find the local lowest price (valley price) and sell it at the next local highest price (peak price). Then we accumulate all of those local profits.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    peak := prices[<span class="number">0</span>]</span><br><span class="line">    valley := prices[<span class="number">0</span>]</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        valley = prices[i]</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        peak = prices[i]</span><br><span class="line">        result += peak - valley</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="keyword">int</span>, length)</span><br><span class="line">    <span class="comment">// dp[i][0] on day i we are holding stock</span></span><br><span class="line">    <span class="comment">// dp[i][1] on day i we don&#x27;t have stock</span></span><br><span class="line">    dp[<span class="number">0</span>] = [<span class="number">2</span>]<span class="keyword">int</span>&#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="comment">// stock we got from day i - 1, or stock we are going to buy on day i</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">        <span class="comment">// we don&#x27;t have stock from day i - 1, or we are going to sell stock we got from day i - 1</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[length - <span class="number">1</span>][<span class="number">0</span>], dp[length - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II&quot; class=&quot;headerlink&quot; title=&quot;122. Best Time t</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
    <category term="Dynamic Programming" scheme="http://blog.beendless.com/tags/Dynamic-Programming/"/>
    
    <category term="Stock Exchange" scheme="http://blog.beendless.com/tags/Stock-Exchange/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Problems - I</title>
    <link href="http://blog.beendless.com/2021/10/03/Greedy%20%20Problems%20I/"/>
    <id>http://blog.beendless.com/2021/10/03/Greedy%20%20Problems%20I/</id>
    <published>2021-10-03T17:25:24.000Z</published>
    <updated>2021-10-04T05:04:44.655Z</updated>
    
    <content type="html"><![CDATA[<p>Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. So <strong>the problems where choosing locally optimal also leads to global solution are best fit for Greedy</strong>.</p><h2 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.com/problems/assign-cookies/">455. Assign Cookies</a></h2><p>If every child is content, then all children are content. So local optimal leads to a global optimal solution. We can use greedy. Now we want to make more child happy, we can use greedy algorithm to give the children whose gratitude is lower first.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="keyword">int</span>, s []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(g) &amp;&amp; j &lt; <span class="built_in">len</span>(s); j++&#123;</span><br><span class="line">        <span class="keyword">if</span> g[i] &lt;= s[i] &#123;</span><br><span class="line">            i++</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a><a href="https://leetcode.com/problems/wiggle-subsequence/">376. Wiggle Subsequence</a></h2><p>a. Greedy solution</p><p>If all connected neighbour nodes are wiggle, the whole slice will be wiggle, it means we can use greedy algorithm. We can also draw the wave with all elements in the slice, our target is to calculate how many peaks (positive/negative) in the wave, here the peak is elements which left diff and right diff have different symbols.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    previous := <span class="number">0</span></span><br><span class="line">    current := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        current = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span> &amp;&amp; previous &lt;= <span class="number">0</span>) || (current &lt; <span class="number">0</span> &amp;&amp; previous &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming solution. Since we want to get the <strong>maximum number</strong>, the first algorithm in our mind will be dynamic programming. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">    dpUp := <span class="number">1</span></span><br><span class="line">    dpDown := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">            dpUp = dpDown + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">            dpDown = dpUp + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dpUp &gt; dpDown &#123;</span><br><span class="line">        <span class="keyword">return</span> dpUp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpDown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></h2><p>A naive solution will be using a two level nested for loop to go through all combinations of subsets.</p><p>a. Greedy implementation</p><p>The idea of using greedy algorithm is when calculating the local maximum sum, if the current sum of all previous elements are negative, we will reset the start point as the current element.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := nums[<span class="number">0</span>]</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; result &#123;</span><br><span class="line">            result = sum</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := nums[<span class="number">0</span>]</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i - <span class="number">1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result &lt; dp[i] &#123;</span><br><span class="line">            result = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := nums[<span class="number">0</span>]</span><br><span class="line">    dp := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp &lt; <span class="number">0</span> &#123;</span><br><span class="line">            dp = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp = dp + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result &lt; dp &#123;</span><br><span class="line">            result = dp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Devide and conquer </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    getCrossMiddleMaxSubArray := <span class="function"><span class="keyword">func</span><span class="params">(start, end, middle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> middle &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i := middle - <span class="number">1</span>; i &gt;= start; i-- &#123;</span><br><span class="line">                sum += nums[i]</span><br><span class="line">                <span class="keyword">if</span> sum &gt; left &#123;</span><br><span class="line">                    left = sum</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> middle &lt; end &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i := middle + <span class="number">1</span>; i &lt;= end; i++ &#123;</span><br><span class="line">                sum += nums[i]</span><br><span class="line">                <span class="keyword">if</span> sum &gt; right &#123;</span><br><span class="line">                    right = sum</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + nums[middle] + right</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> getMaxSubArray <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    getMaxSubArray = <span class="function"><span class="keyword">func</span><span class="params">(start, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == end &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (start + end) / <span class="number">2</span></span><br><span class="line">        left := getMaxSubArray(start, mid)</span><br><span class="line">        right := getMaxSubArray(mid + <span class="number">1</span>, end)</span><br><span class="line">        middle := getCrossMiddleMaxSubArray(start, end, mid)</span><br><span class="line">        <span class="keyword">return</span> max(max(left, middle), right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMaxSubArray(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><p>a. Greedy solution</p><p>To gian the maximum amount of profit, we just need to accumulate the position profits if we buy it on the previous day and sell it on the next day.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        profit := prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> profit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result += profit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Peak &amp; Valley solution</p><p>A naive approach is find the local lowest price (valley price) and sell it at the next local highest price (peak price). Then we accumulate all of those local profits.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    peak := prices[<span class="number">0</span>]</span><br><span class="line">    valley := prices[<span class="number">0</span>]</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        valley = prices[i]</span><br><span class="line">        <span class="keyword">for</span> i &lt; length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        peak = prices[i]</span><br><span class="line">        result += peak - valley</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Dynamic programming</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(prices)</span><br><span class="line">    dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="keyword">int</span>, length)</span><br><span class="line">    <span class="comment">// dp[i][0] on day i we are holding stock</span></span><br><span class="line">    <span class="comment">// dp[i][1] on day i we don&#x27;t have stock</span></span><br><span class="line">    dp[<span class="number">0</span>] = [<span class="number">2</span>]<span class="keyword">int</span>&#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="comment">// stock we got from day i - 1, or stock we are going to buy on day i</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">        <span class="comment">// we don&#x27;t have stock from day i - 1, or we are going to sell stock we got from day i - 1</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[length - <span class="number">1</span>][<span class="number">0</span>], dp[length - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious a</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Greedy" scheme="http://blog.beendless.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Chessboard</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Chessboard/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Chessboard/</id>
    <published>2021-10-02T05:25:24.000Z</published>
    <updated>2021-10-07T18:22:22.650Z</updated>
    
    <content type="html"><![CDATA[<p>Backtracking can also be used to solve chessboard problems.</p><h2 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a><a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="keyword">string</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid := <span class="function"><span class="keyword">func</span><span class="params">(row, col <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; col; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[row][i] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i, j = i - <span class="number">1</span>, j + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(row <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == n &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</span><br><span class="line">            <span class="keyword">for</span> i, boardRow := <span class="keyword">range</span> board &#123;</span><br><span class="line">                temp[i] = strings.Join(boardRow, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isValid(row, col) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                backtracking(row + <span class="number">1</span>)</span><br><span class="line">                board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a><a href="https://leetcode.com/problems/n-queens-ii/">52. N-Queens II</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="keyword">string</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid := <span class="function"><span class="keyword">func</span><span class="params">(row, col <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; col; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[row][i] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, j := row, col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i, j = i - <span class="number">1</span>, j + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(row <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == n &#123;</span><br><span class="line">            result++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isValid(row, col) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                backtracking(row + <span class="number">1</span>)</span><br><span class="line">                board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    isValid := <span class="function"><span class="keyword">func</span><span class="params">(row, col <span class="keyword">int</span>, value <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == value || board[row][i] == value&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        squareX := (row / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        squareY := (col / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> board[i + squareX][j + squareY] == value &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> k := <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++ &#123;</span><br><span class="line">                        <span class="keyword">if</span> isValid(i, j, <span class="keyword">byte</span>(k)) &#123;</span><br><span class="line">                            board[i][j] = <span class="keyword">byte</span>(k)</span><br><span class="line">                            <span class="keyword">if</span> backtracking() &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    backtracking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="980-Unique-Paths-III"><a href="#980-Unique-Paths-III" class="headerlink" title="980. Unique Paths III"></a><a href="https://leetcode.com/problems/unique-paths-iii/">980. Unique Paths III</a></h2><p>A classical backtracking problem. The backtracking state transition function is <code>backtracking(i, j) = backtracking(i + 1, j) + backtracking(i - 1, j) + backtracking(i, j - 1) + backtracking(i, j + 1)</code>, also we need to keep tracking the global state of the grid.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsIII</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    visited := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, m)</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    start := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    end := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        visited[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                start = []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> grid[i][j] == <span class="number">2</span> &#123;</span><br><span class="line">                end = []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> grid[i][j] == <span class="number">-1</span> &#123;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isSuccess := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x != end[<span class="number">0</span>] || y != end[<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> !visited[i][j] &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> visit <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span></span><br><span class="line">    visit = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> isSuccess(i, j) &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j] &#123;</span><br><span class="line">            visited[i<span class="number">-1</span>][j] = <span class="literal">true</span></span><br><span class="line">            visit(i<span class="number">-1</span>, j)</span><br><span class="line">            visited[i<span class="number">-1</span>][j] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; m &amp;&amp; !visited[i + <span class="number">1</span>][j] &#123;</span><br><span class="line">            visited[i+<span class="number">1</span>][j] = <span class="literal">true</span></span><br><span class="line">            visit(i+<span class="number">1</span>, j)</span><br><span class="line">            visited[i+<span class="number">1</span>][j] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>] &#123;</span><br><span class="line">            visited[i][j<span class="number">-1</span>] = <span class="literal">true</span></span><br><span class="line">            visit(i, j - <span class="number">1</span>)</span><br><span class="line">            visited[i][j<span class="number">-1</span>] = <span class="literal">false</span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt; n &amp;&amp; !visited[i][j + <span class="number">1</span>] &#123;</span><br><span class="line">            visited[i][j+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">            visit(i, j + <span class="number">1</span>)   </span><br><span class="line">            visited[i][j+<span class="number">1</span>] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visit(start[<span class="number">0</span>], start[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Backtracking can also be used to solve chessboard problems.&lt;/p&gt;
&lt;h2 id=&quot;51-N-Queens&quot;&gt;&lt;a href=&quot;#51-N-Queens&quot; class=&quot;headerlink&quot; title=&quot;51.</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://blog.beendless.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Subsets</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Subsets/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Subsets/</id>
    <published>2021-10-02T03:05:24.000Z</published>
    <updated>2021-10-03T05:22:26.977Z</updated>
    
    <content type="html"><![CDATA[<p>Backtracking can also help us to get all subsets of a given slice. If Combination and Partitioning problems can be converted to get root-to-leaf paths during a tree DFS traversal, Subsets can be treated as getting all root-to-node paths during a tree DFS traversal.</p><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            backtracking(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h2><p>It’s similar to #78, the only difference is we can’t have duplicated subsets, which means we can’t pick the same value at the same tree level during traversal.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path := <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            backtracking(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="491-Increasing-Subsequences"><a href="#491-Increasing-Subsequences" class="headerlink" title="491. Increasing Subsequences"></a><a href="https://leetcode.com/problems/increasing-subsequences/">491. Increasing Subsequences</a></h2><p>Since we can’t sort the given slice, so we have to use a hashmap / array to save the used nodes in the same layer.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apth) == length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        used := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span>(path) &gt; <span class="number">0</span> &amp;&amp; path[<span class="built_in">len</span>(path) - <span class="number">1</span>] &gt; nums[i]) || used[nums[i]] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[nums[i]] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">                <span class="built_in">copy</span>(temp, path)</span><br><span class="line">                result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Backtracking can also help us to get all subsets of a given slice. If Combination and Partitioning problems can be converted to get root-</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Subsets" scheme="http://blog.beendless.com/tags/Subsets/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Partioning</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Partitioning/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Partitioning/</id>
    <published>2021-10-02T01:05:24.000Z</published>
    <updated>2021-10-02T01:07:37.589Z</updated>
    
    <content type="html"><![CDATA[<p>Partitioning is another classical problem which can be solved with backtracking algorithm.</p><h2 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    isParlindrom := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>; i &lt; j; i, j := i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == length &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isParlindrom(s[index:i + <span class="number">1</span>]) &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, s[index: i + <span class="number">1</span>])</span><br><span class="line">                backtracking(i + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a><a href="https://leetcode.com/problems/restore-ip-addresses/">93. Restore IP Addresses</a></h2><p>We need to consider the edge case that some numbers start with 0 since golang’s <code>strconv.Atoi</code> will convert those string to integer successfully.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &gt; length &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index == length &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, strings.Join(path, <span class="string">&quot;.&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i - index &lt;= <span class="number">2</span> &#123;</span><br><span class="line">                num, _ := strconv.Atoi(s[index:i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> (i - index == <span class="number">2</span> &amp;&amp; num &lt; <span class="number">100</span>) || (i - index == <span class="number">1</span> &amp;&amp; num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> num &lt; <span class="number">256</span> &#123;</span><br><span class="line">                    path = <span class="built_in">append</span>(path, s[index:i + <span class="number">1</span>])</span><br><span class="line">                    backtracking(i + <span class="number">1</span>)</span><br><span class="line">                    path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Partitioning is another classical problem which can be solved with backtracking algorithm.&lt;/p&gt;
&lt;h2 id=&quot;131-Palindrome-Partitioning&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://blog.beendless.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking - Combinations</title>
    <link href="http://blog.beendless.com/2021/10/01/Backtracking%20-%20Combinations/"/>
    <id>http://blog.beendless.com/2021/10/01/Backtracking%20-%20Combinations/</id>
    <published>2021-10-01T20:35:24.000Z</published>
    <updated>2021-10-01T22:19:19.821Z</updated>
    
    <content type="html"><![CDATA[<p>Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time (by time, here, is referred to the time elapsed till reaching any level of the search tree). Usually we can consider backtracking as DFS recursively traversal.</p><h2 id="Backtracking-template"><a href="#Backtracking-template" class="headerlink" title="Backtracking template"></a>Backtracking template</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtracking</span><span class="params">(...args)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> stop_condition &#123;</span><br><span class="line">        <span class="comment">// Update the result set</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nodes_in_current_layer(...args) &#123;</span><br><span class="line">        <span class="comment">// Down to next layer</span></span><br><span class="line">        backtracking(...args, i + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Go back to the upper layer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-Binary-search-tree/">77. Combinations</a></h2><p>We can’t use a naive bruth force algorithm to solve this one, since it’s almost impossible to write a N-layers nested for loop.</p><p>a. Naive backtracking solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n, k, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt;= n; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Remove the unnecessary backtracking branches</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n, k <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n, k, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// For example, given n = 4, k = 3, if path is empty, n - (k - 0) + 1 = 2 means the last valid index can be 2</span></span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt;= n - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.com/problems/combination-sum-iii/">216. Combination Sum III</a></h2><p>Similar to #77, we can use the backtracking template to solve it.</p><p>a. Naive backtracking solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    results := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(k, n, index, sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            <span class="keyword">if</span> sum == n &#123;</span><br><span class="line">                temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">                <span class="built_in">copy</span>(temp, path)</span><br><span class="line">                results = <span class="built_in">append</span>(results, temp)  </span><br><span class="line">            &#125;             </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>, sum + i)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Remove the unnecessary backtracking branches</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(k, n, index, sum)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            <span class="keyword">if</span> sum == n &#123;</span><br><span class="line">                temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">                <span class="built_in">copy</span>(temp, path)</span><br><span class="line">                result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; <span class="number">9</span> - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>, sum + i)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></h2><p>The only difference between #216 and this one is we can reuse the elements of the slice. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(candidates)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(target, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            backtracking(target - candidates[i], i)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h2><p>Since we don’t know how long the given digits will be, we have to use backtracking.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        digitsMap := [<span class="number">10</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">            <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">            <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">            <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">            <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">            <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">        &#125;</span><br><span class="line">        path := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">        backtracking = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, <span class="keyword">string</span>(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            digit, _ := strconv.Atoi(<span class="keyword">string</span>(digits[index]))</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(digitsMap[digit]); i++ &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, digitsMap[digit][i])</span><br><span class="line">                backtracking(index + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II</a></h2><p>Since we can convert a combination backtracking problem to a DFS traversal problem,  if we don’t want to have the duplicated combination result item, it means we can’t pick duplicated nodes from the same layer of a tree. According to the backtracking template, in side of the backtracking for-loop we are handling the same layer logic (push/pop). At this point, if the given candidates is a sorted slice, we just need to compare if the previous element equals to the current element in the same layer.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(candidates)</span><br><span class="line">    sort.Ints(candidates)</span><br><span class="line">    <span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(target, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(temp, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            backtracking(target - candidates[i], i + <span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a tim</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Backtracking" scheme="http://blog.beendless.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Modify Trees</title>
    <link href="http://blog.beendless.com/2021/09/27/Modify%20Trees/"/>
    <id>http://blog.beendless.com/2021/09/27/Modify%20Trees/</id>
    <published>2021-09-28T06:35:24.000Z</published>
    <updated>2021-09-29T05:03:34.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-Binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a></h2><p>Highed balanced means left nodes and right nodes have the minimized same size difference.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    node := &amp;TreeNode&#123;nums[mid], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    node.Left = sortedArrayToBST(nums[:mid])</span><br><span class="line">    node.Right = sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></h2><p>Naive BST recursively traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></h2><p>Naive BST recursively traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">            <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root.Left</span><br><span class="line">            &#125;</span><br><span class="line">            node := root.Right</span><br><span class="line">            <span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                node = node.Left</span><br><span class="line">            &#125;</span><br><span class="line">            node.Left = root.Left</span><br><span class="line">            <span class="keyword">return</span> root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">            root.Right = deleteNode(root.Right, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.Left = deleteNode(root.Left, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a><a href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a></h2><p>Since it’s a BST, we can avoid some calculation by comparing the root value with low, high value.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.Right, low, high)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.Left, low, high)</span><br><span class="line">        &#125;</span><br><span class="line">        root.Left = trimBST(root.Left, low, high)</span><br><span class="line">        root.Right = trimBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h2><p>Since Inorder BST is a sorted slice, for greater tree, we need to get a reversed slice, which means we can still follow the Inorder traversal of the tree but right child node first.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, current)</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            current = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            sum += current.Val</span><br><span class="line">            current.Val = sum</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;108-Convert-Sorted-Array-to-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#108-Convert-Sorted-Array-to-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Search in Trees</title>
    <link href="http://blog.beendless.com/2021/09/27/Search%20in%20Trees/"/>
    <id>http://blog.beendless.com/2021/09/27/Search%20in%20Trees/</id>
    <published>2021-09-28T04:35:24.000Z</published>
    <updated>2021-09-28T06:07:26.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></h2><p>Naive BST query.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret *TreeNode</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Val == val &#123;</span><br><span class="line">            ret = current</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> current.Val &gt; val &#123;</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h2><p>Since Inorder Traversal a BST we will get a sorted list, we just need to compare the previous value with current value during the traversal.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    previous := math.Inf(<span class="number">-1</span>)</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">float64</span>(node.Val) &lt;= previous &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            previous = <span class="keyword">float64</span>(node.Val)</span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST</a></h2><p>a. In Order transverse of BST with stack, we can set up two pointers to check the difference</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">100001</span></span><br><span class="line">    <span class="keyword">var</span> previous, current <span class="keyword">int</span></span><br><span class="line">    node := root</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> count &gt; <span class="number">0</span> &#123;</span><br><span class="line">                previous = current</span><br><span class="line">            &#125;</span><br><span class="line">            current = node.Val</span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">1</span> &amp;&amp; ret &gt; current - previous &#123;</span><br><span class="line">                ret = current - previous</span><br><span class="line">            &#125;</span><br><span class="line">            count++</span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Recurrsively Inorder Traversal with two pointers</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(node.Left)</span><br><span class="line">            data = <span class="built_in">append</span>(data, node.Val)</span><br><span class="line">            dfs(node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    min := data[<span class="number">1</span>] - data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">2</span>; j &lt; <span class="built_in">len</span>(data); i, j = i + <span class="number">1</span>, j + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> min &gt; data[j] - data[i] &#123;</span><br><span class="line">            min = data[j] - data[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree</a></h2><p>Since it’s a BST, we can get a sorted slice with inorder traversal of the tree. Once we have the sorted slice, we can use two pointers sliding window to get a mode result. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    maxCount := <span class="number">1</span></span><br><span class="line">    previous := <span class="number">100001</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(root.Left)</span><br><span class="line">            <span class="keyword">if</span> previous == root.Val &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count &gt; maxCount &#123;</span><br><span class="line">                maxCount = count</span><br><span class="line">                result = []<span class="keyword">int</span>&#123;root.Val&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> count == maxCount &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            previous = root.Val</span><br><span class="line">            dfs(root.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A naive solution which can apply to all trees (not only binary tree) is we create a frequence map with a tree traversal. Then sort the map values and get the higher frequency list.</p><h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h2><p>a. Pass down parent informatin layer by layer to get two slices, then find the first common items.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [[root, []]];</span><br><span class="line">    <span class="keyword">let</span> pPath, qPath;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &amp;&amp; (!pPath || !qPath)) &#123;</span><br><span class="line">        <span class="keyword">const</span> [node, ancestor] = stack.shift();</span><br><span class="line">        <span class="keyword">const</span> newAncestor = ancestor.concat([node]);</span><br><span class="line">        <span class="keyword">if</span> (node.val === p.val) &#123;</span><br><span class="line">            pPath = newAncestor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val === q.val) &#123;</span><br><span class="line">            qPath = newAncestor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">            stack.push([node.left, newAncestor]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">            stack.push([node.right, newAncestor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = root;</span><br><span class="line">    <span class="keyword">while</span>(pPath.length &amp;&amp; qPath.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = pPath.shift();</span><br><span class="line">        <span class="keyword">const</span> y = qPath.shift();</span><br><span class="line">        <span class="keyword">if</span> (x.val === y.val) &#123;</span><br><span class="line">            result = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>b. If we search a tree from bottom layer to top, we can easily get the ancestor node. Postorder traversal can help us to go from bottom to up.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || root == p || root == q &#123;   <span class="comment">// edge case</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)    </span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;    <span class="comment">// Postorder Traversal</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h2><p>Since it’s a BST, we can compare the value to remove some unnecessary calculation.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;700-Search-in-a-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#700-Search-in-a-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;700. Search in a Binary </summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Construct and Update a Tree</title>
    <link href="http://blog.beendless.com/2021/09/23/Construct-and-Update-a-Tree/"/>
    <id>http://blog.beendless.com/2021/09/23/Construct-and-Update-a-Tree/</id>
    <published>2021-09-23T07:00:24.000Z</published>
    <updated>2021-09-23T07:15:33.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. Construct Binary Search Tree from Preorder Traversal</a></h2><p>Based on the preorder traversal definition for a BST, the first element in the slice is always coming from the root node, we can split the rest elements into two parts from the element which is no less than the root node for child nodes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bstFromPreorder</span><span class="params">(preorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    length := <span class="built_in">len</span>(preorder)</span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">0</span> &#123;</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = preorder[<span class="number">0</span>]</span><br><span class="line">        i := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">            <span class="keyword">if</span> preorder[i] &gt;= root.Val &#123;</span><br><span class="line">               <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        root.Left = bstFromPreorder(preorder[<span class="number">1</span>:i])</span><br><span class="line">        root.Right = bstFromPreorder(preorder[i:])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p>The last element in postorder slice is the root node, with this information, we can split inorder to a left subtree and a right subtree. Since now we know the amount of nodes in the left subtree, we can go back to split the postorder list into two.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        rootValue := postorder[<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.Val = rootValue</span><br><span class="line">        inorderLeftIndex := indexOf(inorder, rootValue)</span><br><span class="line">        inorderLeft := inorder[:inorderLeftIndex]</span><br><span class="line">        inorderRight := inorder[inorderLeftIndex + <span class="number">1</span>:]</span><br><span class="line">        postorderLeft := postorder[:<span class="built_in">len</span>(inorderLeft)]</span><br><span class="line">        postorderRight := postorder[<span class="built_in">len</span>(inorderLeft):<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.Left = buildTree(inorderLeft, postorderLeft)</span><br><span class="line">        root.Right = buildTree(inorderRight, postorderRight)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2><p>Similar to the above one, we can get the root node first from preorder slice.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">        rootValueIndex := indexOf(inorder, rootValue)</span><br><span class="line">        inorderLeft := inorder[:rootValueIndex]</span><br><span class="line">        inorderRight := inorder[rootValueIndex + <span class="number">1</span>:]</span><br><span class="line">        preorderLeft := preorder[<span class="number">1</span>:<span class="built_in">len</span>(inorderLeft) + <span class="number">1</span>]</span><br><span class="line">        preorderRight := preorder[<span class="built_in">len</span>(inorderLeft) + <span class="number">1</span>:]</span><br><span class="line">        root = &amp;TreeNode&#123;</span><br><span class="line">            Val: rootValue,</span><br><span class="line">            Left: buildTree(preorderLeft, inorderLeft),</span><br><span class="line">            Right: buildTree(preorderRight, inorderRight),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal</a></h2><p>With the second element in preorder slice, we can split postorder slice into two sub slices. With this information we can go back to split the preorder slice into two sub slices with the same sizes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructFromPrePost</span><span class="params">(preorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = rootValue</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">1</span> &#123;</span><br><span class="line">            leftValue := preorder[<span class="number">1</span>]</span><br><span class="line">            leftValueIndex := indexOf(postorder, leftValue)</span><br><span class="line">            postorderLeft := postorder[:leftValueIndex + <span class="number">1</span>]</span><br><span class="line">            postorderRight := postorder[leftValueIndex + <span class="number">1</span>:<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">            preorderLeft := preorder[<span class="number">1</span>:<span class="built_in">len</span>(postorderLeft) + <span class="number">1</span>]</span><br><span class="line">            preorderRight := preorder[<span class="built_in">len</span>(postorderRight) + <span class="number">1</span>:]    </span><br><span class="line">            root.Left = constructFromPrePost(preorderLeft, postorderLeft)</span><br><span class="line">            root.Right = constructFromPrePost(preorderRight, postorderRight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></h2><p>Find the maximu value, then split the slice with the max value to get two sub slices.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxIndex</span><span class="params">(haystack []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := <span class="number">-1</span></span><br><span class="line">    ret := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] &gt; max &#123;</span><br><span class="line">            max = haystack[i]</span><br><span class="line">            ret = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        max := maxIndex(nums)</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = nums[max]</span><br><span class="line">        root.Left = constructMaximumBinaryTree(nums[:max])</span><br><span class="line">        root.Right = constructMaximumBinaryTree(nums[max+<span class="number">1</span>:])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a><a href="https://leetcode.com/problems/maximum-binary-tree-ii/">998. Maximum Binary Tree II</a></h2><p>With the idea from the above one, since <code>Suppose b is a copy of a with the value val appended to it. </code>, it means <code>b</code> can only be the root node or part of right subtree based on the tree construction rule.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoMaxTree</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &amp;&amp; root.Val &gt; val &#123;</span><br><span class="line">        root.Right = insertIntoMaxTree(root.Right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">        Val: val,</span><br><span class="line">        Left: root,</span><br><span class="line">        Right: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> root1 != <span class="literal">nil</span> || root2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = root2</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = root1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = &amp;TreeNode&#123;</span><br><span class="line">                Val: root1.Val + root2.Val,</span><br><span class="line">                Left: mergeTrees(root1.Left, root2.Left),</span><br><span class="line">                Right: mergeTrees(root1.Right, root2.Right),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1008-Construct-Binary-Search-Tree-from-Preorder-Traversal&quot;&gt;&lt;a href=&quot;#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal&quot; clas</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Tree Properties</title>
    <link href="http://blog.beendless.com/2021/09/19/Tree-Properties/"/>
    <id>http://blog.beendless.com/2021/09/19/Tree-Properties/</id>
    <published>2021-09-20T04:35:24.000Z</published>
    <updated>2021-09-22T06:54:02.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h2><p>a. DFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testSymmetric(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSymmetric</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; b != <span class="literal">nil</span> &amp;&amp; a.Val == b.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> testSymmetric(a.Left, b.Right) &amp;&amp; testSymmetric(a.Right, b.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i, j := <span class="number">0</span>, n - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !testSymmetric(queue[i], queue[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[i]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSymmetric</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; b != <span class="literal">nil</span> &amp;&amp; a.Val == b.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h2><p>Same to the symmetric tree question.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &amp;&amp; p.Val == q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572. Subtree of Another Tree"></a><a href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree</a></h2><p>a. Naive DFS solution</p><p>We will check if the given two trees are the same or not, if not, then check if the subRoot is the sub tree of the root tree’s child nodes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isSameTree(root, subRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root != <span class="literal">nil</span> &amp;&amp; (isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &amp;&amp; p.Val == q.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Serialize tree to string and compare the string</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> toString(root) == toString(subRoot) || (root != <span class="literal">nil</span> &amp;&amp; (isSubtree(root.Left, subRoot) ||  isSubtree(root.Right, subRoot)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strconv.Itoa(root.Val) + toString(root.Left) + toString(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h2><p>a. DFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        max := math.Inf(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> _, node := <span class="keyword">range</span> root.Children &#123;</span><br><span class="line">            depth := maxDepth(node)</span><br><span class="line">            <span class="keyword">if</span> max &lt; <span class="keyword">float64</span>(depth) &#123;</span><br><span class="line">                max = <span class="keyword">float64</span>(depth)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max == math.Inf(<span class="number">-1</span>) &#123;</span><br><span class="line">            max = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="keyword">int</span>(max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*Node&#123;root&#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            length := <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">                node := queue[i]</span><br><span class="line">                <span class="keyword">for</span> _, child := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, child)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[length:]</span><br><span class="line">            n++</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.com/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h2><p>a. DFS recursion</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.Left) + countNodes(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS recursion</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            n++</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Complete tree property</p><p>For a full binary tree, it has 2<sup>depth</sup> - 1 nodes. Since a full binary tree is a subset of complete tree, based on the equation, we can calculate the nodes of a given tree if it’s left most child node’s depth equals it’s right most child note’s depth.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := root.Left</span><br><span class="line">    right := root.Right</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">        l++</span><br><span class="line">        left = left.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> right != <span class="literal">nil</span> &#123;</span><br><span class="line">        r++</span><br><span class="line">        right = right.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l == r &#123; <span class="comment">// It&#x27;s a full binary tree</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; l - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root.Left) + countNodes(root.Right) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h2><p>The key to solve this challenge is to get the depth of given node’s left and right child.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(root.Left)</span><br><span class="line">        right := getDepth(root.Right)</span><br><span class="line">        <span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(left - right)) &gt; <span class="keyword">float64</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(root.Left)</span><br><span class="line">        right := getDepth(root.Right)</span><br><span class="line">        <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths</a></h2><p>When we traversing the tree, we need to push the parent nodes inforamtion to a queue.</p><p>a. DFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="keyword">string</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, paths <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            p := paths + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(node.Val)</span><br><span class="line">            <span class="keyword">if</span> paths == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                p = strconv.Itoa(node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, p)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    dfs(node.Left, p)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    dfs(node.Right, p)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="keyword">type</span> TreeNodeWithPath <span class="keyword">struct</span> &#123;</span><br><span class="line">    Node *TreeNode</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNodeWithPath&#123;&amp;TreeNodeWithPath&#123;</span><br><span class="line">        Node: root,</span><br><span class="line">        Path: strconv.Itoa(root.Val),</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            twp := queue[i]</span><br><span class="line">            <span class="keyword">if</span> twp.Node.Left == <span class="literal">nil</span> &amp;&amp; twp.Node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, twp.Path)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> twp.Node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, &amp;TreeNodeWithPath&#123;</span><br><span class="line">                        Node: twp.Node.Left,</span><br><span class="line">                        Path: twp.Path + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(twp.Node.Left.Val),</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> twp.Node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, &amp;TreeNodeWithPath&#123;</span><br><span class="line">                        Node: twp.Node.Right,</span><br><span class="line">                        Path: twp.Path + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(twp.Node.Right.Val),</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h2><p>a. DFS recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := <span class="number">0</span></span><br><span class="line">        right := sumOfLeftLeaves(root.Right)</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &amp;&amp; root.Left.Left == <span class="literal">nil</span> &amp;&amp; root.Left.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            left = root.Left.Val</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = sumOfLeftLeaves(root.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS with stack (PreOrder)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, current)</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            current = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> current.Left != <span class="literal">nil</span> &amp;&amp; current.Left.Left == <span class="literal">nil</span> &amp;&amp; current.Left.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result += current.Left.Val</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h2><p>a. Naive solution is to use BFS and get the first node of last layer.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[i]</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue) == n &#123;</span><br><span class="line">            result = queue[<span class="number">0</span>].Val</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. The bottom-left leaf node means two things: 1) this node laid at the bottom layer 2) this node will be reached first if we go with DFS In-Order traversal.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unc findBottomLeftValue(root *TreeNode) <span class="keyword">int</span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    ret := root.Val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="keyword">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &amp;&amp; level &gt; max &#123;</span><br><span class="line">            max = level</span><br><span class="line">            ret = node.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(node.Left, level + <span class="number">1</span>)    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            dfs(node.Right, level + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a></h2><p>Naive DFS solution with target passing down to the next layer</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a></h2><p>Similar to the above one, we just need to store extra information</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;    </span><br><span class="line">    <span class="keyword">type</span> TreeNodeWithPath <span class="keyword">struct</span> &#123;</span><br><span class="line">        node *TreeNode</span><br><span class="line">        path []<span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    cloneAppend := <span class="function"><span class="keyword">func</span><span class="params">(source []<span class="keyword">int</span>, item <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(source))</span><br><span class="line">        <span class="built_in">copy</span>(ret, source)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(ret, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNodeWithPath, <span class="keyword">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNodeWithPath, targetSum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> root.node.Left == <span class="literal">nil</span> &amp;&amp; root.node.Right == <span class="literal">nil</span> &amp;&amp; root.node.Val == targetSum &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, cloneAppend(root.path, root.node.Val))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(&amp;TreeNodeWithPath&#123;</span><br><span class="line">                    node: root.node.Left,</span><br><span class="line">                    path: cloneAppend(root.path, root.node.Val),</span><br><span class="line">                &#125;, targetSum - root.node.Val)</span><br><span class="line">                dfs(&amp;TreeNodeWithPath&#123;</span><br><span class="line">                    node: root.node.Right,</span><br><span class="line">                    path: cloneAppend(root.path, root.node.Val),</span><br><span class="line">                &#125;, targetSum - root.node.Val)   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(&amp;TreeNodeWithPath&#123;</span><br><span class="line">        node: root,</span><br><span class="line">        path: []<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">    &#125;, targetSum)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>If we need to clone a slice in golang, usually we will use the snipped as below:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>, b == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>But it’s not perfect, if a is nil, b wont’ be nil. So we need to use <code>b = append(a[:0:0], a...)</code></p><ul><li><a href="https://github.com/go101/go101/wiki/How-to-perfectly-clone-a-slice%3F">https://github.com/go101/go101/wiki/How-to-perfectly-clone-a-slice%3F</a></li></ul><h2 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/">437. Path Sum III</a></h2><p>Based on the problem description, we need to find out all paths from all subtrees of the given tree which sum equals to the targetSum. There’s a pitfall as the edge case, once we got one path (which means the targetSum reaches to 0), we still need to continue the searching since the rest path below may get a total sum 0.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> targetPath(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">targetPath</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        restPath := targetPath(root.Left, targetSum - root.Val) + targetPath(root.right, targetSum - root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Val == targetSum &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + restPath</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> restPath</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;101-Symmetric-Tree&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/p</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Tree Traversals BFS</title>
    <link href="http://blog.beendless.com/2021/09/14/Tree-Traversals-BFS/"/>
    <id>http://blog.beendless.com/2021/09/14/Tree-Traversals-BFS/</id>
    <published>2021-09-15T05:35:24.000Z</published>
    <updated>2021-09-19T19:00:06.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h2><p>a. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution</p><p>The idea is passing the level while traversing the tree</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>, result *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(*result) &lt; level &#123;</span><br><span class="line">            *result = <span class="built_in">append</span>(*result, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        (*result)[level - <span class="number">1</span>] = <span class="built_in">append</span>((*result)[level - <span class="number">1</span>], node.Val)</span><br><span class="line">        dfs(node.Left, level + <span class="number">1</span>, result)</span><br><span class="line">        dfs(node.Right, level + <span class="number">1</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(root, <span class="number">1</span>, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h2><p>We just need to reverse the result of BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h2><p>We just need to get the right most item (last item) of each layer by using BFS.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i == n - <span class="number">1</span> &#123;</span><br><span class="line">                    result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">                &#125;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></h2><p>Get the sum of each level by using BFS or DFS with level information, then claculate the average.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">averageOfLevels</span><span class="params">(root *TreeNode)</span> []<span class="title">float64</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="keyword">float64</span> = <span class="number">0</span></span><br><span class="line">        item := <span class="number">0</span>    <span class="comment">// Track the not nil item</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                sum += <span class="keyword">float64</span>(node.Val)</span><br><span class="line">                item++</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> item &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, sum / <span class="keyword">float64</span>(item))   </span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *Node)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*Node&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                <span class="keyword">for</span> _, child := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, child)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestValues</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*TreeNode&#123;root&#125;</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            max := queue[<span class="number">0</span>].Val</span><br><span class="line">            <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                node := queue[<span class="number">0</span>]</span><br><span class="line">                queue = queue[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> node.Val &gt; max &#123;</span><br><span class="line">                    max = node.Val</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">                &#125;</span><br><span class="line">                n--</span><br><span class="line">            &#125;</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            result = <span class="built_in">append</span>(result, max)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h2><p>a. A naive solution will be using BFS to traverse the tree.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*Node&#123;root&#125;</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    queue[i - <span class="number">1</span>].Next = queue[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> queue[i].Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Left)</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[n:]</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution. Since the given tree is a full complete tree, we can easily use the parent node to get it’s siblings children nodes.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    parent := root</span><br><span class="line">    <span class="keyword">for</span> parent.Left != <span class="literal">nil</span> &#123; <span class="comment">// Has child node</span></span><br><span class="line">        current := parent</span><br><span class="line">        <span class="keyword">for</span> current != <span class="literal">nil</span> &#123; <span class="comment">// Moving from left to right</span></span><br><span class="line">            current.Left.Next = current.Right</span><br><span class="line">            <span class="keyword">if</span> current.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">                current.Right.Next = current.Next.Left</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent.Left <span class="comment">// Move to the next layer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.wang/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node.html">https://leetcode.wang/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node.html</a></li></ul><h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117. Populating Next Right Pointers in Each Node II</a></h2><p>The only difference between this one and the above one is we need to verify the node’s right child before push the into the queue.</p><p>a. A naive solution will be using BFS to traverse the tree.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*Node&#123;root&#125;</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    queue[i - <span class="number">1</span>].Next = queue[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> queue[i].Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> queue[i].Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, queue[i].Right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[n:]</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        dummy := &amp;Node&#123;&#125;    <span class="comment">// Dummy pointer which points to the first node in current node&#x27;s child layer</span></span><br><span class="line">        tail := dummy       <span class="comment">// Using tail node to construct a linked list which head is dummy node</span></span><br><span class="line">        <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> current.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                tail.Next = current.Left</span><br><span class="line">                tail := tail.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> current.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                tail.Next = current.Right</span><br><span class="line">                tail = tail.Next</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">        current = dummy.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html">https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html</a></li></ul><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><p>a. BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue := []*TreeNode&#123;root&#125;</span><br><span class="line">        n := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> node := queue[i]; node != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                        queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                        queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = queue[n:]</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            ret++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getDepth(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDepth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(node.Left)</span><br><span class="line">        right := getDepth(node.Right)</span><br><span class="line">        <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;102-Binary-Tree-Level-Order-Traversal&quot;&gt;&lt;a href=&quot;#102-Binary-Tree-Level-Order-Traversal&quot; class=&quot;headerlink&quot; title=&quot;102. Binary Tree L</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
    <category term="BFS" scheme="http://blog.beendless.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Tree Traversals DFS</title>
    <link href="http://blog.beendless.com/2021/09/13/Tree-Traversals-DFS/"/>
    <id>http://blog.beendless.com/2021/09/13/Tree-Traversals-DFS/</id>
    <published>2021-09-14T05:45:24.000Z</published>
    <updated>2021-10-03T04:54:43.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, inorderTraversal(root.Left)...)</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, inorderTraversal(root.Right)...)   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Iterative solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    stack := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;  <span class="comment">// reach to the left most node and push node to stack so we can pop left child node before parent node</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Val)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]  <span class="comment">// pop parent node out if it doesn&#x27;t have left child node</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val) <span class="comment">// switch to right child node</span></span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Morris Traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous := current.Left</span><br><span class="line">            <span class="keyword">for</span> previous.Right != <span class="literal">nil</span> &amp;&amp; previous.Right != current &#123;</span><br><span class="line">                previous = previous.Right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                previous.Right = current</span><br><span class="line">                current = current.Left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == current &#123;</span><br><span class="line">                previous.Right = <span class="literal">nil</span></span><br><span class="line">                result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">                current = current.Right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">        result = <span class="built_in">append</span>(result, preorderTraversal(root.Left)...)</span><br><span class="line">        result = <span class="built_in">append</span>(result, preorderTraversal(root.Right)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Iterative traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Morris Traversal</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">            current = current.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous := current.Left</span><br><span class="line">            <span class="keyword">for</span> previous.Right != <span class="literal">nil</span> &amp;&amp; previous.Right != current &#123;</span><br><span class="line">                previous = previous.Right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">                previous.Right = current</span><br><span class="line">                current = current.Left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Right == current &#123;</span><br><span class="line">                previous.Right = <span class="literal">nil</span></span><br><span class="line">                current = current.Right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">145. Binary Tree Postorder Traversal</a></h2><p>a. Recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, postorderTraversal(root.Left)...)</span><br><span class="line">        result = <span class="built_in">append</span>(result, postorderTraversal(root.Right)...)</span><br><span class="line">        result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Iterative solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    stack := []*TreeNode&#123;root, root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; node == stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] &#123; <span class="comment">// First time to visit the parent node</span></span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, node.Val) <span class="comment">// Second time to visit the parent node</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. Morris Traversal</p><p>The idea is we make a PreOrder traversal but right node first, and reverse the result. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    current := root</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">            current = current.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous := current.Right <span class="comment">// get the right child&#x27;s left most child, and point it back to parent node</span></span><br><span class="line">            <span class="keyword">for</span> previous.Left != <span class="literal">nil</span> &amp;&amp; previous.Left != current &#123;</span><br><span class="line">                previous = previous.Left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, current.Val)</span><br><span class="line">                previous.Left = current</span><br><span class="line">                current = current.Right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> previous.Left == current &#123;</span><br><span class="line">                previous.Left = <span class="literal">nil</span></span><br><span class="line">                current = current.Left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h2><p>a. BFS solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. DFS solution</p><p>The idea is passing the level while traversing the tree</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>, result *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(*result) &lt; level &#123;</span><br><span class="line">            *result = <span class="built_in">append</span>(*result, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        (*result)[level - <span class="number">1</span>] = <span class="built_in">append</span>((*result)[level - <span class="number">1</span>], node.Val)</span><br><span class="line">        dfs(node.Left, level + <span class="number">1</span>, result)</span><br><span class="line">        dfs(node.Right, level + <span class="number">1</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(root, <span class="number">1</span>, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h2><p>We just need to reverse the result of BFS</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                temp = <span class="built_in">append</span>(temp, node.Val)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h2><p>We need to pay attention to the edge case when a node only have one child node.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getDepth(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDepth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := getDepth(node.Left)</span><br><span class="line">        right := getDepth(node.Right)</span><br><span class="line">        <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + right</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h2><p>a. DFS recursive solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. BFS with queue</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := queue[i]</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">                node.Left, node.Right = node.Right, node.Left</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. DFS without recursion (PreOrder)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Left, node.Right = node.Right, node.Left</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d. DFS without recursion (PostOrder)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;root, root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; node == stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.Left, node.Right =  node.Right, node.Left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="332-Reconstruct-Itinerary"><a href="#332-Reconstruct-Itinerary" class="headerlink" title="332. Reconstruct Itinerary"></a><a href="https://leetcode.com/problems/reconstruct-itinerary/">332. Reconstruct Itinerary</a></h2><p>We are given a direct graph, and we need to get the node traversal result. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findItinerary</span><span class="params">(tickets [][]<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ticketsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, ticket := <span class="keyword">range</span> tickets &#123;</span><br><span class="line">        ticketsMap[ticket[<span class="number">0</span>]] = <span class="built_in">append</span>(ticketsMap[ticket[<span class="number">0</span>]], ticket[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> ticketsMap &#123;</span><br><span class="line">        sort.Strings(ticketsMap[key])</span><br><span class="line">    &#125;</span><br><span class="line">    path := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> visit <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span></span></span><br><span class="line">    visit = <span class="function"><span class="keyword">func</span><span class="params">(from <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ticketsMap[from]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            to := ticketsMap[from][<span class="number">0</span>]</span><br><span class="line">            ticketsMap[from] = ticketsMap[from][<span class="number">1</span>:]</span><br><span class="line">            visit(to)</span><br><span class="line">        &#125;</span><br><span class="line">        path = <span class="built_in">append</span>(path, from)</span><br><span class="line">    &#125;</span><br><span class="line">    visit(<span class="string">&quot;JFK&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(path) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        path[i], path[j] = path[j], path[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;94-Binary-Tree-Inorder-Traversal&quot;&gt;&lt;a href=&quot;#94-Binary-Tree-Inorder-Traversal&quot; class=&quot;headerlink&quot; title=&quot;94. Binary Tree Inorder Trav</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://blog.beendless.com/tags/Binary-Tree/"/>
    
    <category term="DFS" scheme="http://blog.beendless.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Heap and Heap Sort</title>
    <link href="http://blog.beendless.com/2021/09/13/Heap-and-Heap-Sort/"/>
    <id>http://blog.beendless.com/2021/09/13/Heap-and-Heap-Sort/</id>
    <published>2021-09-13T19:45:23.000Z</published>
    <updated>2021-09-13T23:17:16.601Z</updated>
    
    <content type="html"><![CDATA[<p>A <code>Heap</code> is a special Tree-based data structure in which the tree is a complete binary tree. Generally, there are two types of <code>Heap</code>: Max-Heap (root node is greater than its child nodes) and Min-Heap (root node is smaller than its child nodes).</p><p>Golang’s standard library shipped with a <a href="https://pkg.go.dev/container/heap"><code>heap</code> container</a>. We can also use a slice to simulate a Heap. Let’s take <code>Max-Heap</code> as an example.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Heap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x)</span><br><span class="line">    index := <span class="built_in">len</span>(*h) - <span class="number">1</span></span><br><span class="line">    parent := (index - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// (index + 1) / 2 - 1, 1 based index node n, it&#x27;s child is 2n and 2n + 1,</span></span><br><span class="line">    <span class="keyword">for</span> parent &gt;= <span class="number">0</span> &amp;&amp; (*h)[index] &gt; (*h)[parent] &#123;</span><br><span class="line">        (*)h[index], (*)h[parent] = (*)h[parent], (*)h[index]</span><br><span class="line">        index = parent</span><br><span class="line">        parent = (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*h) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ret := (*h)[<span class="number">0</span>]</span><br><span class="line">        length := <span class="built_in">len</span>(*h)</span><br><span class="line">        (*h)[<span class="number">0</span>] = (*h)(length - <span class="number">1</span>)</span><br><span class="line">        parent := <span class="number">0</span></span><br><span class="line">        left := <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; length - <span class="number">1</span> &#123;</span><br><span class="line">            child := left</span><br><span class="line">            <span class="keyword">if</span> left + <span class="number">1</span> &lt; length - <span class="number">1</span> &amp;&amp; (*h)[left] &lt; (*h)[left + <span class="number">1</span>]&#123;</span><br><span class="line">                child++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (*h)[parent] &lt; (*h)[child] &#123;</span><br><span class="line">                (*)h[parent], (*)h[child] = (*)h[child], (*)h[parent]</span><br><span class="line">                parent = child</span><br><span class="line">                left = <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *h = (*h)[:length - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Heap</code> is always used to implement the priority queue since it’s search and pop time complexities are both O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex" xmlns="http://www.w3.org/2000/svg" width="5.614ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 2481.2 900" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-2061" d=""></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(278,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(778,0)"></use></g><g data-mml-node="mo" transform="translate(1278,0)"><use data-c="2061" xlink:href="#MJX-1-TEX-N-2061"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1444.7,0)"><g data-mml-node="msub"><g data-mml-node="mi"></g><g data-mml-node="mn" transform="translate(33,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1881.2,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></g></svg></mjx-container>).</p><h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h2><p>A naive implementation will be to get the frequency map , to store the (key, frequency) into a 2D-slice and to sort the matrix with quick sort. Then return the last <code>k</code>th element of the slice.</p><p>a. Bucket Sort solution</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mapping[v]++</span><br><span class="line">        <span class="keyword">if</span> mapping[v] &gt; max &#123;</span><br><span class="line">            max = mapping[v]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, max + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        buckets[v] = <span class="built_in">append</span>(buckets[v], k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> max &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, buckets[max]...)</span><br><span class="line">        k -= <span class="built_in">len</span>(buckets[max])</span><br><span class="line">        max--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. We can consider the frequency as a priority, so with the help of <code>Max-Heap</code>, we can solve it in  O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 3247.9 900" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-2061" d=""></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(766.7,0)"><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(278,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(778,0)"></use></g><g data-mml-node="mo" transform="translate(2044.7,0)"><use data-c="2061" xlink:href="#MJX-1-TEX-N-2061"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2211.3,0)"><g data-mml-node="msub"><g data-mml-node="mi"></g><g data-mml-node="mn" transform="translate(33,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2647.9,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></g></svg></mjx-container>)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mapping[v]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap := [][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        <span class="comment">// Push into the heap</span></span><br><span class="line">        heap = <span class="built_in">append</span>(heap, [<span class="number">2</span>]<span class="keyword">int</span>&#123;v, k&#125;)</span><br><span class="line">        index := <span class="built_in">len</span>(heap) - <span class="number">1</span></span><br><span class="line">        parent := (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> index &gt; <span class="number">0</span> &amp;&amp; heap[parent][<span class="number">0</span>] &lt; heap[index][<span class="number">0</span>] &#123;</span><br><span class="line">            heap[parent], heap[index] = heap[index], heap[parent]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, heap[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        heap[<span class="number">0</span>] = heap[<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        parent := <span class="number">0</span></span><br><span class="line">        left := <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &#123;</span><br><span class="line">            child := left</span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &amp;&amp; heap[left][<span class="number">0</span>] &lt; heap[left + <span class="number">1</span>][<span class="number">0</span>] &#123;</span><br><span class="line">                child = left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> heap[parent][<span class="number">0</span>] &lt; heap[child][<span class="number">0</span>] &#123;</span><br><span class="line">                heap[parent], heap[child] = heap[child], heap[parent]</span><br><span class="line">                parent = child</span><br><span class="line">                left = <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heap = heap[:<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="692-Top-K-Frequent-Words"><a href="#692-Top-K-Frequent-Words" class="headerlink" title="692. Top K Frequent Words"></a><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a></h2><p>a. Bucket sorting</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(words []<span class="keyword">string</span>, k <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        mapping[word]++</span><br><span class="line">        <span class="keyword">if</span> mapping[word] &gt; max &#123;</span><br><span class="line">            max = mapping[word]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket := <span class="built_in">make</span>([][]<span class="keyword">string</span>, max + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        bucket[value] = <span class="built_in">append</span>(bucket[value], key)</span><br><span class="line">    &#125;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> max &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sort.Strings(bucket[max])</span><br><span class="line">        length := <span class="built_in">len</span>(bucket[max])</span><br><span class="line">        <span class="keyword">if</span> k &lt; length &#123;</span><br><span class="line">            length = k</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, bucket[max][:length]...)</span><br><span class="line">        k -= length</span><br><span class="line">        max--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Max-Heap</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(words []<span class="keyword">string</span>, k <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        mapping[word]++</span><br><span class="line">    &#125;</span><br><span class="line">    heap := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, _ := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">        heap = <span class="built_in">append</span>(heap, key)</span><br><span class="line">        index := <span class="built_in">len</span>(heap) - <span class="number">1</span></span><br><span class="line">        parent := (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> index &gt; <span class="number">0</span> &amp;&amp; compareFn(heap[parent], heap[index], mapping) &#123;</span><br><span class="line">            heap[parent], heap[index] = heap[index], heap[parent]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = (index - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, heap[<span class="number">0</span>])</span><br><span class="line">        heap[<span class="number">0</span>] = heap[<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        index := <span class="number">0</span></span><br><span class="line">        left := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &#123;</span><br><span class="line">            child := left</span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt; <span class="built_in">len</span>(heap) - <span class="number">1</span> &amp;&amp; compareFn(heap[left], heap[left + <span class="number">1</span>], mapping) &#123;</span><br><span class="line">                child = left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> compareFn(heap[index], heap[child], mapping) &#123;</span><br><span class="line">                heap[index], heap[child] = heap[child], heap[index]</span><br><span class="line">                index = child</span><br><span class="line">                left = <span class="number">2</span> * index + <span class="number">1</span>   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heap = heap[:<span class="built_in">len</span>(heap) - <span class="number">1</span>]</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareFn</span><span class="params">(a, b <span class="keyword">string</span>, mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> mapping[b] &lt; mapping[a] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mapping[b] &gt; mapping[a] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Compare(b, a) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A &lt;code&gt;Heap&lt;/code&gt; is a special Tree-based data structure in which the tree is a complete binary tree. Generally, there are two types of</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Bucket Sort" scheme="http://blog.beendless.com/tags/Bucket-Sort/"/>
    
    <category term="Top K Frequent" scheme="http://blog.beendless.com/tags/Top-K-Frequent/"/>
    
    <category term="Heap" scheme="http://blog.beendless.com/tags/Heap/"/>
    
    <category term="Priority Queue" scheme="http://blog.beendless.com/tags/Priority-Queue/"/>
    
  </entry>
  
  <entry>
    <title>Query with Stack</title>
    <link href="http://blog.beendless.com/2021/09/12/Query-with-Stack/"/>
    <id>http://blog.beendless.com/2021/09/12/Query-with-Stack/</id>
    <published>2021-09-12T22:45:23.000Z</published>
    <updated>2021-10-06T19:15:41.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></h2><p>We can simply iterate over all items from the given string and compare the adjacent values each time with the help of stack before pushing the element in. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    bs = <span class="built_in">append</span>(bs, s[<span class="number">0</span>])</span><br><span class="line">    dict := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">byte</span>&#123;</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> v, ok := dict[s[i]]; ok &amp;&amp; <span class="built_in">len</span>(bs) &gt; <span class="number">0</span> &amp;&amp; v == bs[<span class="built_in">len</span>(bs) - <span class="number">1</span>] &#123;</span><br><span class="line">            bs = bs[:<span class="built_in">len</span>(bs) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bs = <span class="built_in">append</span>(bs, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(bs) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h2><p>a. Use stack to iterate the string, similar to the parentheses validation one above.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(bs) &gt; <span class="number">0</span> &amp;&amp; s[i] == bs[<span class="built_in">len</span>(bs) - <span class="number">1</span>]&#123;</span><br><span class="line">            bs = bs[:<span class="built_in">len</span>(bs) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bs = <span class="built_in">append</span>(bs, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Use two pointers</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(s); j++&#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; bs[i] == bs[i - <span class="number">1</span>] &#123;</span><br><span class="line">            i--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs[:i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h2><p>For arithmetic related problems, we usually use stack to solve it. The temporary computation result can be pushed to the top of the stack.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, token := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">        integer, err := strconv.Atoi(token)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums, integer)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            length := <span class="built_in">len</span>(nums)</span><br><span class="line">            x, y := nums[length - <span class="number">2</span>], nums[length - <span class="number">1</span>]</span><br><span class="line">            temp := <span class="number">0</span></span><br><span class="line">            <span class="keyword">switch</span> token &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                temp = x + y</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                temp = x - y</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                temp = x * y</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                temp = x / y</span><br><span class="line">            &#125;</span><br><span class="line">            nums[length - <span class="number">2</span>] = temp</span><br><span class="line">            nums = nums[:length - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h2><p>A naive solution will be store the sliding window items into a slice and calculating the maximum value each time, the time complexity will be O(n * k). We can consider storing the sliding window items in a desending slice(Queue), it always has the maximum value at the top of the queue.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[queue[<span class="built_in">len</span>(queue) - <span class="number">1</span>]] &#123;</span><br><span class="line">            queue = queue[:<span class="built_in">len</span>(queue) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">        <span class="keyword">for</span> queue[<span class="number">0</span>] &lt;= i - k &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, nums[queue[<span class="number">0</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/">71. Simplify Path</a></h2><p><code>Stack</code> is one of the best data structure to solve Path manipulation realted problems. </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifyPath</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    dirs := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    paths := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(paths); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> paths[i] == <span class="string">&quot;..&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(dirs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                dirs = dirs[:<span class="built_in">len</span>(dirs) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> paths[i] == <span class="string">&quot;&quot;</span> || paths[i] == <span class="string">&quot;.&quot;</span> || paths[i] == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dirs = <span class="built_in">append</span>(dirs, paths[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + strings.Join(dirs, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a><a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></h2><p>a. Stack solution</p><p>Since it’s a pattern matching problem, the first algorithm in our toolbox could be stack. If we store the previous index of current valid parentheses on the top of the stack, we can quickly get the length of the valid parentheses end with current index by using the current index minus the peak value at the stack</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    stack := []<span class="keyword">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> max &lt; i - stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] &#123;</span><br><span class="line">                    max = i - stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. Dynamic programming solution</p><p>Usually if the requirement is to get a min/max value, we can try dynamic programming.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    dp := <span class="built_in">make</span>(<span class="keyword">int</span>[], <span class="built_in">len</span>(s))  <span class="comment">// dp[i] denotes the valid parentheses string end with index i, it means if s[i] is left parentheses, dp[i] is 0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;   <span class="comment">// for cases end with a valid parentheses .....()</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span> &#123; <span class="comment">// for cases end with two right parentheses  .......))</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] += dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> max &lt; dp[i] &#123;</span><br><span class="line">                max = dp[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;20-Valid-Parentheses&quot;&gt;&lt;a href=&quot;#20-Valid-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;20. Valid Parentheses&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://blog.beendless.com/tags/Stack/"/>
    
    <category term="Dynamic Programming" scheme="http://blog.beendless.com/tags/Dynamic-Programming/"/>
    
    <category term="Sliding Window" scheme="http://blog.beendless.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Design a Stack with Queue</title>
    <link href="http://blog.beendless.com/2021/09/12/Design-a-Stack-with-Queue/"/>
    <id>http://blog.beendless.com/2021/09/12/Design-a-Stack-with-Queue/</id>
    <published>2021-09-12T18:45:23.000Z</published>
    <updated>2021-09-12T19:58:05.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><p>We can’t use the similar solution we did for <a href="/2021/09/11/Design-a-Queue-with-Stack/">Design a Queue with Stack</a>. It is because unlike <code>Stack</code>,  moving elements from one <code>Queue</code> to another one won’t change the sequence of elements. We have to pop out all previous elements added into the queue when adding a new element, in this way we can simulate a Stack.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !q.Empty() &#123;</span><br><span class="line">        ret = (*q)[<span class="number">0</span>]</span><br><span class="line">        *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span><span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !q.Empty() &#123;</span><br><span class="line">        ret = (*q)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    m *Queue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyStack</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> MyStack&#123;</span><br><span class="line">        &amp;Queue&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.m.Empty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.m.Top()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.m.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*((*s).m))</span><br><span class="line">    s.m.Push(x)</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        s.m.Push(s.m.Pop())</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;225-Implement-Stack-using-Queues&quot;&gt;&lt;a href=&quot;#225-Implement-Stack-using-Queues&quot; class=&quot;headerlink&quot; title=&quot;225. Implement Stack using Q</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Queue" scheme="http://blog.beendless.com/tags/Queue/"/>
    
    <category term="Stack" scheme="http://blog.beendless.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Design a Queue with Stack</title>
    <link href="http://blog.beendless.com/2021/09/11/Design-a-Queue-with-Stack/"/>
    <id>http://blog.beendless.com/2021/09/11/Design-a-Queue-with-Stack/</id>
    <published>2021-09-11T18:45:23.000Z</published>
    <updated>2021-09-12T18:51:12.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></h2><p>Since <code>Queue</code> is <code>FIFO</code> but <code>Stack</code> is <code>FILO</code>. If we need to use <code>Stack</code> to implement a <code>Queue</code>, we need to use at least two <code>Stack</code>s. So we use one stack which only handle <code>Push</code> operations, and another <code>Stack</code> which only handle <code>Pop</code>/<code>Peek</code> operations. And we move elements from the <code>Pop</code> only <code>Stack</code> to the other one when <code>Pop</code>/<code>Peek</code> get called. It will reverse the <code>FILO</code> stack elements sequence after that. So we get a <code>FIFO</code> sequence.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !s.Empty() &#123;</span><br><span class="line">        lastIndex := <span class="built_in">len</span>(*s) - <span class="number">1</span></span><br><span class="line">        ret = (*s)[lastIndex]</span><br><span class="line">        *s = (*s)[:lastIndex]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span><span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> !s.Empty() &#123;</span><br><span class="line">        ret = (*s)[<span class="built_in">len</span>(*s) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    m, n *Stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        &amp;Stack&#123;&#125;,</span><br><span class="line">        &amp;Stack&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    q.m.Push(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    q.Peek()</span><br><span class="line">    <span class="keyword">return</span> q.n.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.n.Empty() &#123;</span><br><span class="line">        <span class="keyword">for</span> !q.m.Empty() &#123;</span><br><span class="line">            q.n.Push(q.m.Pop())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.n.Peek()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyQueue)</span><span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q.m.Empty() &amp;&amp; q.n.Empty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.com/problems/implement-queue-using-stacks/discuss/64206/Short-O">https://leetcode.com/problems/implement-queue-using-stacks/discuss/64206/Short-O</a>(1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;232-Implement-Queue-using-Stacks&quot;&gt;&lt;a href=&quot;#232-Implement-Queue-using-Stacks&quot; class=&quot;headerlink&quot; title=&quot;232. Implement Queue using S</summary>
      
    
    
    
    <category term="CS" scheme="http://blog.beendless.com/categories/CS/"/>
    
    
    <category term="Golang" scheme="http://blog.beendless.com/tags/Golang/"/>
    
    <category term="Algorithms" scheme="http://blog.beendless.com/tags/Algorithms/"/>
    
    <category term="Leetcode" scheme="http://blog.beendless.com/tags/Leetcode/"/>
    
    <category term="Queue" scheme="http://blog.beendless.com/tags/Queue/"/>
    
    <category term="Stack" scheme="http://blog.beendless.com/tags/Stack/"/>
    
  </entry>
  
</feed>
