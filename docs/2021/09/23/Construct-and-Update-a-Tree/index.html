<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Move Fast, Live Happily, With No End"><title>Construct and Update a Tree | Beendless ~ 快节奏,慢生活,无止境</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-38171545-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Construct and Update a Tree</h1><a id="logo" href="/.">Beendless ~ 快节奏,慢生活,无止境</a><p class="description">Move Fast, Live Happily, With No End</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Construct and Update a Tree</h1><div class="post-meta">2021-09-23<span> | </span><span class="category"><a href="/categories/CS/">CS</a></span></div><div class="post-content"><h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. Construct Binary Search Tree from Preorder Traversal</a></h2><p>Based on the preorder traversal definition for a BST, the first element in the slice is always coming from the root node, we can split the rest elements into two parts from the element which is no less than the root node for child nodes.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bstFromPreorder</span><span class="params">(preorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    length := <span class="built_in">len</span>(preorder)</span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">0</span> &#123;</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = preorder[<span class="number">0</span>]</span><br><span class="line">        i := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">            <span class="keyword">if</span> preorder[i] &gt;= root.Val &#123;</span><br><span class="line">               <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        root.Left = bstFromPreorder(preorder[<span class="number">1</span>:i])</span><br><span class="line">        root.Right = bstFromPreorder(preorder[i:])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p>The last element in postorder slice is the root node, with this information, we can split inorder to a left subtree and a right subtree. Since now we know the amount of nodes in the left subtree, we can go back to split the postorder list into two.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        rootValue := postorder[<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.Val = rootValue</span><br><span class="line">        inorderLeftIndex := indexOf(inorder, rootValue)</span><br><span class="line">        inorderLeft := inorder[:inorderLeftIndex]</span><br><span class="line">        inorderRight := inorder[inorderLeftIndex + <span class="number">1</span>:]</span><br><span class="line">        postorderLeft := postorder[:<span class="built_in">len</span>(inorderLeft)]</span><br><span class="line">        postorderRight := postorder[<span class="built_in">len</span>(inorderLeft):<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.Left = buildTree(inorderLeft, postorderLeft)</span><br><span class="line">        root.Right = buildTree(inorderRight, postorderRight)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2><p>Similar to the above one, we can get the root node first from preorder slice.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">        rootValueIndex := indexOf(inorder, rootValue)</span><br><span class="line">        inorderLeft := inorder[:rootValueIndex]</span><br><span class="line">        inorderRight := inorder[rootValueIndex + <span class="number">1</span>:]</span><br><span class="line">        preorderLeft := preorder[<span class="number">1</span>:<span class="built_in">len</span>(inorderLeft) + <span class="number">1</span>]</span><br><span class="line">        preorderRight := preorder[<span class="built_in">len</span>(inorderLeft) + <span class="number">1</span>:]</span><br><span class="line">        root = &amp;TreeNode&#123;</span><br><span class="line">            Val: rootValue,</span><br><span class="line">            Left: buildTree(preorderLeft, inorderLeft),</span><br><span class="line">            Right: buildTree(preorderRight, inorderRight),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal</a></h2><p>With the second element in preorder slice, we can split postorder slice into two sub slices. With this information we can go back to split the preorder slice into two sub slices with the same sizes.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(haystack []<span class="keyword">int</span>, needle <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructFromPrePost</span><span class="params">(preorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = rootValue</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">1</span> &#123;</span><br><span class="line">            leftValue := preorder[<span class="number">1</span>]</span><br><span class="line">            leftValueIndex := indexOf(postorder, leftValue)</span><br><span class="line">            postorderLeft := postorder[:leftValueIndex + <span class="number">1</span>]</span><br><span class="line">            postorderRight := postorder[leftValueIndex + <span class="number">1</span>:<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">            preorderLeft := preorder[<span class="number">1</span>:<span class="built_in">len</span>(postorderLeft) + <span class="number">1</span>]</span><br><span class="line">            preorderRight := preorder[<span class="built_in">len</span>(postorderRight) + <span class="number">1</span>:]    </span><br><span class="line">            root.Left = constructFromPrePost(preorderLeft, postorderLeft)</span><br><span class="line">            root.Right = constructFromPrePost(preorderRight, postorderRight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></h2><p>Find the maximu value, then split the slice with the max value to get two sub slices.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxIndex</span><span class="params">(haystack []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := <span class="number">-1</span></span><br><span class="line">    ret := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] &gt; max &#123;</span><br><span class="line">            max = haystack[i]</span><br><span class="line">            ret = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        max := maxIndex(nums)</span><br><span class="line">        root = &amp;TreeNode&#123;&#125;</span><br><span class="line">        root.Val = nums[max]</span><br><span class="line">        root.Left = constructMaximumBinaryTree(nums[:max])</span><br><span class="line">        root.Right = constructMaximumBinaryTree(nums[max+<span class="number">1</span>:])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree-ii/">998. Maximum Binary Tree II</a></h2><p>With the idea from the above one, since <code>Suppose b is a copy of a with the value val appended to it. </code>, it means <code>b</code> can only be the root node or part of right subtree based on the tree construction rule.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoMaxTree</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &amp;&amp; root.Val &gt; val &#123;</span><br><span class="line">        root.Right = insertIntoMaxTree(root.Right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">        Val: val,</span><br><span class="line">        Left: root,</span><br><span class="line">        Right: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> root1 != <span class="literal">nil</span> || root2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = root2</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            root = root1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = &amp;TreeNode&#123;</span><br><span class="line">                Val: root1.Val + root2.Val,</span><br><span class="line">                Left: mergeTrees(root1.Left, root2.Left),</span><br><span class="line">                Right: mergeTrees(root1.Right, root2.Right),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/Golang/"><i class="fa fa-tag"></i>Golang</a><a href="/tags/Algorithms/"><i class="fa fa-tag"></i>Algorithms</a><a href="/tags/Leetcode/"><i class="fa fa-tag"></i>Leetcode</a><a href="/tags/Binary-Tree/"><i class="fa fa-tag"></i>Binary Tree</a></div><div class="post-nav"><a class="pre" href="/2021/09/27/Search%20in%20Trees/">Search in Trees</a><a class="next" href="/2021/09/19/Tree-Properties/">Tree Properties</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.beendless.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BC%B2%E6%BD%AE%EF%B9%A3%E9%80%80%E6%BD%AE/">漲潮﹣退潮</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%84%A1%E7%9F%A5%EF%B9%A3%E6%97%A0%E7%9F%A5/">無知﹣无知</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A1%8C%E8%B5%B0%E7%9A%84%E6%A8%B9%E8%8B%97/">行走的樹苗</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Async/" style="font-size: 15px;">Async</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="/tags/DevOps/" style="font-size: 15px;">DevOps</a> <a href="/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/tags/Archetecture/" style="font-size: 15px;">Archetecture</a> <a href="/tags/Deep-Learning/" style="font-size: 15px;">Deep Learning</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ConvnetJS/" style="font-size: 15px;">ConvnetJS</a> <a href="/tags/Google-Colab/" style="font-size: 15px;">Google Colab</a> <a href="/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/tags/Deep-Learning-with-TensorFlow-2-and-Keras/" style="font-size: 15px;">Deep Learning with TensorFlow 2 and Keras</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Functional-Programming/" style="font-size: 15px;">Functional Programming</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Algorithms/" style="font-size: 15px;">Algorithms</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Binary-Search/" style="font-size: 15px;">Binary Search</a> <a href="/tags/Time-complexity/" style="font-size: 15px;">Time complexity</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Matrix/" style="font-size: 15px;">Matrix</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/KMP/" style="font-size: 15px;">KMP</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/Bucket-Sort/" style="font-size: 15px;">Bucket Sort</a> <a href="/tags/Top-K-Frequent/" style="font-size: 15px;">Top K Frequent</a> <a href="/tags/Heap/" style="font-size: 15px;">Heap</a> <a href="/tags/Priority-Queue/" style="font-size: 15px;">Priority Queue</a> <a href="/tags/Binary-Tree/" style="font-size: 15px;">Binary Tree</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/Backtracking/" style="font-size: 15px;">Backtracking</a> <a href="/tags/Subsets/" style="font-size: 15px;">Subsets</a> <a href="/tags/Greedy/" style="font-size: 15px;">Greedy</a> <a href="/tags/JumpGame/" style="font-size: 15px;">JumpGame</a> <a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/Stock-Exchange/" style="font-size: 15px;">Stock Exchange</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/Sliding-Window/" style="font-size: 15px;">Sliding Window</a> <a href="/tags/Knapsack/" style="font-size: 15px;">Knapsack</a> <a href="/tags/Monotonic-Stack/" style="font-size: 15px;">Monotonic Stack</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Mastering-Go/" style="font-size: 15px;">Mastering Go</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/10/19/Multi-Stage%20Golang%20Docker%20Image/">Multi-Stage Golang Docker Image Build and Kubernetes Deployment</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/18/Mastering%20Go%20Notes/">Mastering Go Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/16/Monotonic%20Stack/">Monotonic Stack</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/14/Dynamic%20Programming%20IV/">Dynamic Programming IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/13/Dynamic%20Programming%20III/">Dynamic Programming III</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/12/Stock%20Exchange%20Problems/">Stock Exchange Problems</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/09/Knapsack%20Problem%20II/">Knapsack Problems II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/08/Dynamic%20Programming%20II/">Dynamic Programming II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/07/Knapsack%20Problem%20I/">Knapsack Problems I</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/06/Dynamic%20Programming%20I/">Dynamic Programming I</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Beendless ~ 快节奏,慢生活,无止境.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>