<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Move Fast, Live Happily, With No End"><title>JumpGame  Problems | Beendless ~ 快节奏,慢生活,无止境</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-38171545-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JumpGame  Problems</h1><a id="logo" href="/.">Beendless ~ 快节奏,慢生活,无止境</a><p class="description">Move Fast, Live Happily, With No End</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JumpGame  Problems</h1><div class="post-meta">2021-10-03<span> | </span><span class="category"><a href="/categories/CS/">CS</a></span></div><div class="post-content"><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">55. Jump Game</a></h2><p>a. Greedy solutions</p>
<p>At each step, a greedy jump can give us the local optimal furthest solution. Our global solution can be found in if we always take the greedy jump.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    distance := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= distance; i++ &#123; <span class="comment">// Note: here we use distance to control which items we can check</span></span><br><span class="line">        <span class="keyword">if</span> distance &lt; i + nums[i] &#123;</span><br><span class="line">            distance = i + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> distance &gt;= length - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. Dynamic programming</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; length; j++ &#123;</span><br><span class="line">                dp[i + j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a></h2><p>a. Greedy solution</p>
<p>Each time, we will jump to a position which can make us future jumping even further. And each jump will resolve to a coverage range as below, so the total jump steps will be the sum of times we reach to the edge of the coverge range.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 2 | 3 | 1 | 1 | 4 | 5 | 1 | 2 |</span><br><span class="line"></span><br><span class="line">|----------&gt;|</span><br><span class="line">    |--------------&gt;|</span><br><span class="line"></span><br><span class="line">                |--------------&gt;|</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> max &lt; nums[i] + i &#123;  <span class="comment">// Get the next coverage edge</span></span><br><span class="line">            max = nums[i] + i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == end &#123;           <span class="comment">// Switch to the next range with a jump</span></span><br><span class="line">            end = max</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. Dynamic programming</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i + j] == <span class="number">-1</span> &#123;</span><br><span class="line">                dp[i + j] = dp[i] + <span class="number">1</span>   </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> dp[i + j] &gt; dp[i] + <span class="number">1</span> &#123;</span><br><span class="line">                dp[i + j] = dp[i] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-iii/">1306. Jump Game III</a></h2><p>The keypoint here is during the traversal of the recursive, we don’t get lost in a infinite loop. So we need to remember all of the visted nodes in a hash.</p>
<p>a. Recursive solution</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    reachedNodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">var</span> jump <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    jump = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reachedNodes[index] &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        reachedNodes[index] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> index - arr[index] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            jump(index - arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index + arr[index] &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">            jump(index + arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jump(start)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. Queue traversal solution.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    reachedNodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;start&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        index := queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> arr[index] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        reachedNodes[index] = <span class="literal">true</span></span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> index + arr[index] &lt; length &amp;&amp; !reachedNodes[index + arr[index]] &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, index + arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index - arr[index] &lt; length &amp;&amp; !reachedNodes[index - arr[index]] &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, index - arr[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-iv/">1345. Jump Game IV</a></h2><p>This is a classical tree traversal with BFS problem. From each array index we can jump to multiple elements simoteniously, those nextstep elements can be consiered as the tree node’s child nodes. So we jump to all nodes’s children nodes at once which can be considered as one jump (BFS). Since the same value of the nodes can jump to each other, we have to mark the nodes values which have been pushed to the queue to make sure we don’t push the same nodes back to the queue (even we have a visited flag, we can easily run out of memory without another same number flag under this edge case if we have 1000 same value nodes in the slice). </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minJumps</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    jumpIndexes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        jumpIndexes[v] = <span class="built_in">append</span>(jumpIndexes[v], i)</span><br><span class="line">    &#125;</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    queue[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>, length)</span><br><span class="line">    sameNumberVisited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>) <span class="comment">// Have a flag is one thing, another solution is to remove the sameNumber key from the jumpIndexes hashmap.</span></span><br><span class="line">    n := <span class="built_in">len</span>(queue)</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            index := queue[i]</span><br><span class="line">            <span class="keyword">if</span> index == length - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !visited[index] &#123;</span><br><span class="line">                visited[index] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> index - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[index - <span class="number">1</span>]&#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, index - <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> index + <span class="number">1</span> &lt; length &amp;&amp; !visited[index + <span class="number">1</span>] &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, index + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> !sameNumberVisited[arr[index]] &#123;</span><br><span class="line">                    sameNumberVisited[arr[index]] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">for</span> _, v := <span class="keyword">range</span> jumpIndexes[arr[index]] &#123;</span><br><span class="line">                        <span class="keyword">if</span> !visited[v] &#123;</span><br><span class="line">                            queue = <span class="built_in">append</span>(queue, v)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[n:]</span><br><span class="line">        n = <span class="built_in">len</span>(queue)</span><br><span class="line">        result++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1340-Jump-Game-V"><a href="#1340-Jump-Game-V" class="headerlink" title="1340. Jump Game V"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-v/">1340. Jump Game V</a></h2><p>To resolve this problem, we need to understand <code> you can only jump from index i to index j if arr[i] &gt; arr[j] and arr[i] &gt; arr[k] for all indices k between i and j (More formally min(i, j) &lt; k &lt; max(i, j)).</code>. Let’s say we stand at index i, and jumping from i - 1, i + 1 until i - d, i + d inside of for loops. We need to break the loop if we find a k between [i-d, i) or (i, i + d] which makes arr[k] &gt;= arr[i].</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxJumps</span><span class="params">(arr []<span class="keyword">int</span>, d <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(arr)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> jump <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    jump = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[index] == <span class="number">0</span> &#123;</span><br><span class="line">            dp[index] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i := index - <span class="number">1</span>; i &gt;= max(<span class="number">0</span>, index - d) &amp;&amp; arr[i] &lt; arr[index]; i-- &#123;</span><br><span class="line">                dp[index] = max(dp[index], jump(i) + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt;= min(length - <span class="number">1</span>, index + d) &amp;&amp; arr[i] &lt; arr[index]; i++ &#123;</span><br><span class="line">                dp[index] = max(dp[index], jump(i) + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        dp[i] = jump(i)</span><br><span class="line">        result = max(dp[i], result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1696-Jump-Game-VI"><a href="#1696-Jump-Game-VI" class="headerlink" title="1696. Jump Game VI"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-vi/">1696. Jump Game VI</a></h2><p>A naive idea is to iterate over all nodes, so the worse time complexity could be O(n * k) [K = maxJump - minJump] which most likely will cause a TLE issue. This one can be considered as a classic <a href="/tags/Sliding-Window/">sliding window</a> maximum problem. Since dp[i] = nums[i] + max(dp[i - k], … , dp[i - 1]). We just need to maintain the maximum dp value in the sliding window during the iteration.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">01010101010101011111</span><br><span class="line"></span><br><span class="line">|---------(i)------|</span><br><span class="line">    |-----&gt;|</span><br><span class="line">    i-k    i-1</span><br><span class="line">|----------(i + 1)------|</span><br><span class="line">     |-----&gt;|</span><br><span class="line">     i-k+1  i</span><br></pre></td></tr></table></figure>


<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxResult</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;      <span class="comment">// stores the dp indexes of the sliding window items</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        maxSumIndex := queue[<span class="number">0</span>]</span><br><span class="line">        dp[i] = nums[i] + dp[maxSumIndex]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; dp[queue[<span class="built_in">len</span>(queue) - <span class="number">1</span>]] &lt;= dp[i] &#123; <span class="comment">// sliding window queue contains all values in a desending order</span></span><br><span class="line">            queue = queue[:<span class="built_in">len</span>(queue) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; i - queue[<span class="number">0</span>] &gt;= k &#123;  <span class="comment">// remove the index which is going to out of the window</span></span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, dp[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="1871-Jump-Game-VII"><a href="#1871-Jump-Game-VII" class="headerlink" title="1871. Jump Game VII"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-vii/">1871. Jump Game VII</a></h2><p>Same as the above one, a naive dp will get a TLE. A keypoint to solve this problem is we need to avoid the duplicated node visiting. One way is we can use a hashmap to note all visited elements. Another method is that we can bypass the overlap like below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01010101010101011111</span><br><span class="line">  |---------&gt;|</span><br><span class="line">  1          2</span><br><span class="line">    |---------&gt;|</span><br><span class="line">    3          4</span><br></pre></td></tr></table></figure>

<p>The first jump range is 1 ~ 2, the second is 3 ~ 4, here the range 3 ~ 2 doesn’t need to be visited again. With this in mind, we can use tree-like traversal solution with queue or two pointers sliding window to fix this issue.</p>
<p>a. Queue with traversal solution</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(s <span class="keyword">string</span>, minJump <span class="keyword">int</span>, maxJump <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    edge := <span class="number">0</span></span><br><span class="line">    min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        index := queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        left := index + minJump</span><br><span class="line">        right := min(length - <span class="number">1</span>, index + maxJump)</span><br><span class="line">        <span class="keyword">for</span> i := max(edge + <span class="number">1</span>, left); i &lt;= right; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; !visited[i]&#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edge = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. Two pointers</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canReach</span><span class="params">(s <span class="keyword">string</span>, minJump <span class="keyword">int</span>, maxJump <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s[length - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">                <span class="keyword">return</span> b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">        canVisit := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">        canVisit[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        edge := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= edge &amp;&amp; i &lt; length; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> canVisit[i] &#123;</span><br><span class="line">                left := i + minJump</span><br><span class="line">                right := min(length - <span class="number">1</span>, i + maxJump)</span><br><span class="line">                <span class="keyword">for</span> j := max(left, edge + <span class="number">1</span>); j &lt;= right; j++ &#123;</span><br><span class="line">                    <span class="keyword">if</span> s[j] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                        canVisit[j] = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">if</span> j == length - <span class="number">1</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                edge = right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/Golang/"><i class="fa fa-tag"></i>Golang</a><a href="/tags/Algorithms/"><i class="fa fa-tag"></i>Algorithms</a><a href="/tags/Leetcode/"><i class="fa fa-tag"></i>Leetcode</a><a href="/tags/Binary-Tree/"><i class="fa fa-tag"></i>Binary Tree</a><a href="/tags/BFS/"><i class="fa fa-tag"></i>BFS</a><a href="/tags/DFS/"><i class="fa fa-tag"></i>DFS</a><a href="/tags/Greedy/"><i class="fa fa-tag"></i>Greedy</a><a href="/tags/JumpGame/"><i class="fa fa-tag"></i>JumpGame</a><a href="/tags/Dynamic-Programming/"><i class="fa fa-tag"></i>Dynamic Programming</a><a href="/tags/Two-Pointers/"><i class="fa fa-tag"></i>Two Pointers</a><a href="/tags/Sliding-Window/"><i class="fa fa-tag"></i>Sliding Window</a></div><div class="post-nav"><a class="pre" href="/2021/10/05/Greedy%20%20Problems%20II/">Greedy Problems - II</a><a class="next" href="/2021/10/03/Stock%20Exchange%20Problems/">Stock Exchange Problems</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.beendless.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BC%B2%E6%BD%AE%EF%B9%A3%E9%80%80%E6%BD%AE/">漲潮﹣退潮</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%84%A1%E7%9F%A5%EF%B9%A3%E6%97%A0%E7%9F%A5/">無知﹣无知</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A1%8C%E8%B5%B0%E7%9A%84%E6%A8%B9%E8%8B%97/">行走的樹苗</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Async/" style="font-size: 15px;">Async</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="/tags/DevOps/" style="font-size: 15px;">DevOps</a> <a href="/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/tags/Archetecture/" style="font-size: 15px;">Archetecture</a> <a href="/tags/Deep-Learning/" style="font-size: 15px;">Deep Learning</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ConvnetJS/" style="font-size: 15px;">ConvnetJS</a> <a href="/tags/Google-Colab/" style="font-size: 15px;">Google Colab</a> <a href="/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/tags/Deep-Learning-with-TensorFlow-2-and-Keras/" style="font-size: 15px;">Deep Learning with TensorFlow 2 and Keras</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Functional-Programming/" style="font-size: 15px;">Functional Programming</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Algorithms/" style="font-size: 15px;">Algorithms</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Binary-Search/" style="font-size: 15px;">Binary Search</a> <a href="/tags/Time-complexity/" style="font-size: 15px;">Time complexity</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Matrix/" style="font-size: 15px;">Matrix</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/KMP/" style="font-size: 15px;">KMP</a> <a href="/tags/Queue/" style="font-size: 15px;">Queue</a> <a href="/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/tags/Bucket-Sort/" style="font-size: 15px;">Bucket Sort</a> <a href="/tags/Top-K-Frequent/" style="font-size: 15px;">Top K Frequent</a> <a href="/tags/Heap/" style="font-size: 15px;">Heap</a> <a href="/tags/Priority-Queue/" style="font-size: 15px;">Priority Queue</a> <a href="/tags/Binary-Tree/" style="font-size: 15px;">Binary Tree</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/Backtracking/" style="font-size: 15px;">Backtracking</a> <a href="/tags/Subsets/" style="font-size: 15px;">Subsets</a> <a href="/tags/Greedy/" style="font-size: 15px;">Greedy</a> <a href="/tags/JumpGame/" style="font-size: 15px;">JumpGame</a> <a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/Stock-Exchange/" style="font-size: 15px;">Stock Exchange</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/Sliding-Window/" style="font-size: 15px;">Sliding Window</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/10/06/Dynamic%20Programming%20I/">Dynamic Programming I</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/06/Greedy%20%20Problems%20III/">Greedy Problems - III</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/05/Greedy%20%20Problems%20II/">Greedy Problems - II</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/03/JumpGame%20%20Problems/">JumpGame  Problems</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/03/Stock%20Exchange%20Problems/">Stock Exchange Problems</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/03/Greedy%20%20Problems%20I/">Greedy Problems - I</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/01/Backtracking%20-%20Chessboard/">Backtracking - Chessboard</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/01/Backtracking%20-%20Subsets/">Backtracking - Subsets</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/01/Backtracking%20-%20Partitioning/">Backtracking - Partioning</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/01/Backtracking%20-%20Combinations/">Backtracking - Combinations</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Beendless ~ 快节奏,慢生活,无止境.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>